#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Allows entering a dependency context. In that context, slots know what
other slot requested their value, i.e. depend in them. This is done by
keeping a stack of slots that which to be notified of the slots that they
are triggering.
"""

__all__ = ["child"]

from collections import deque
from threading import local
from typing import Optional, TYPE_CHECKING, Tuple, Union

if TYPE_CHECKING:
    from parapy.core.sequence import Sequence


# werkzeug.local.LocalStack class is much slower.
class _Deque(local):

    # while tempting, this breaks the local-to-thread property
    # __slots__ = ('deque')

    def __init__(self, *args, **kwargs):
        super(_Deque, self).__init__(*args, **kwargs)
        self.d = deque()

    def append(self, value):
        return self.d.append(value)

    def pop(self):
        return self.d.pop()

    def clear(self):
        return self.d.clear()

    def __eq__(self, other):
        return self.d.__eq__(other)

    __hash__ = None

    def __ne__(self, other):
        return self.d.__ne__(other)

    def __getitem__(self, item):
        return self.d[item]

    def __bool__(self):
        return bool(self.d)

    def __repr__(self):
        return repr(self.d)

#     def append(self, elem):
#         self.d.append(elem)
#     def pop(self):
#         return self.d.pop()
#         
#     def peek(self):
#         return self.d[-1]
#         
#     def __nonzero__(self):
#         return bool(self.d)
#     def __repr__(self):
#         return repr(self.d)  


class dependency_context(object):
    """
    A context manager to set the global dependency context to a given slot. In practice,
    this means the slot is added to the top of the notify stack.
     
    Use like this::
     
        with dependency_context(the_slot):
            the_slot.set_value(value_function())
             
    In this example, the slots used by the value_function will list the_slot as a dependent.
    """

    def __init__(self, cache):
        """
        @param listener: any object that has an invalidate method.
        """
        assert callable(cache.invalidate)
        self.cache = cache

    def __enter__(self):
        # TODO: check necessary?
        NOTIFY_QUEUE.d.append(self.cache)

    def __exit__(self, *args):
        NOTIFY_QUEUE.d.pop()


class _ChildProxy:
    __slots__ = ("__wrapped__",)  # to support hasattr introspection (pytest)

    index: Union[int, Tuple[int, ...], None]
    previous: Optional['AbstractBase']
    next: Optional['AbstractBase']
    aggregate: 'Sequence'

    def __init__(self, deque: deque):
        self.__wrapped__ = deque

    def __getattr__(self, name):
        if not CHILD_QUEUE.d:
            raise RuntimeError(
                "child object is not available. Did you use the "
                "reference inside a @Part expression?")

        if name == "__this__":  # Return the object wrapped by this `child`
            return CHILD_QUEUE.d[-1]

        return getattr(CHILD_QUEUE.d[-1], name)


CHILD_QUEUE = _Deque()
"""(thread-local) deque used for proxy object :attr:`child`."""
NOTIFY_QUEUE = _Deque()
"""(thread-local) deque used for cache notification"""
EVENT_QUEUE = _Deque()
"""(thread-local) deque used for event queing and dispatch. Entries are of the
form: (obj, slot, new, old), callable"""

child = _ChildProxy(CHILD_QUEUE)
