#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import multiprocessing as mp
import operator
import os
from functools import reduce
from operator import attrgetter, getitem
from typing import Iterable, List, Optional, TYPE_CHECKING

from parapy.core.abstractbase import (
    AbstractBase, NO_SEQUENCE_CONTEXT, SequenceContext, SequenceContextBase)
from parapy.core.attribute import Attribute
from parapy.core.cache import CacheLock
from parapy.core.globs import ICN_DIR, RESERVED_SEQUENCE
from parapy.core.input import Input
from parapy.core.meta import basetype
from parapy.core.parser import PartParser
from parapy.core.utilities import iflatten
from parapy.core.validate import IsInstance

if TYPE_CHECKING:
    from parapy.core.base import Base


def Sequence_type_validator(value, obj, slot):
    if isinstance(value, basetype):
        return True
    elif hasattr(value, "__iter__"):
        return all([Sequence_type_validator(subvalue, obj, slot)
                    for subvalue in value])
    else:
        return False


def _quantify_validator(value, obj):
    if isinstance(obj.type, basetype):
        if isinstance(value, int) or (hasattr(value, "__iter__") and
                                      all(isinstance(s, int) for s in value)):
            return True  # it is a single integer, or an iterable of integers
        else:
            msg = ("if you specify type as a single class, quantify "
                   "should be correctly defined as either an integer or a "
                   "list of integers, not: {!r}")
            return False, msg.format(obj)

    return True  # if type is not a single basetype, quantify can be anything


# TODO RvD: make Sequence subclass of Base class. Creator: RvD
class Sequence(AbstractBase):
    """
    Abstract class for all sequence objects. Usage is typically implicit::

        class MyClass(Base):

            @Part
            def sequence(self, child):
                return Box(quantify=3,
                           width=1,
                           length=child.index + 1,
                           height=child.length * 2)

    This is converted into the explicit form (that you can also use) at run-time::

        class MyClass(Base):

            @Part
            def sequence(self, child):
                return Sequence(type=Box,
                                quantify=3,
                                width=1,
                                length=child.index + 1,
                                height=child.length * 2)

    The sequence object wraps and behaves like a list. You can retrieve individual items using
    standard getitem [idx] notation or other list-supported operations (len, add, etc.).

    >>> seq = MyClass().sequence
    <Sequence (1x3) root.sequence at ...>
    >>> seq.first
    <Box root.sequence[0] at ...>
    >>> seq[0]
    <Box root.sequence[0] at ...>
    >>> seq.last
    <Box root.sequence[2] at ...>
    >>> seq[-1]
    <Box root.sequence[2] at ...>
    >>> seq[0].height
    2
    >>> seq.any.height
    [2, 4, 6]
    >>> seq.sum("height")
    12

    The ``quantify`` or ``type`` inputs can result in multi-dimensional
    sequences. For example, to make a 2-dimensional [3x4] sequence of
    boxes with size, use:

        class MyClass(Base):

            @Part
            def sequence(self, child):
                return Sequence(type=Box,
                                quantify=[3, 4],
                                width=1, length=2, height=child.length * 2)

    Or::
        class MyClass(Base):

            @Part
            def sequence(self, child):
                return Sequence(type=[[Box] * 4] * 3,
                                width=1, length=2, height=child.length * 2)

    >>> seq = MyClass().sequence
    >>> seq.first
    <Box root.sequence[0,0] at ...>
    >>> seq.last
    <Box root.sequence[2,3] at ...>
    """

    __icon__ = os.path.join(ICN_DIR, 'sequence.png')
    __reserved__ = RESERVED_SEQUENCE
    _prev_state = None  # type: SequenceState

    #: a type (Base or subclass of Base) or sequence of types
    #: :type: parapy.core.basetype.basetype | collections.Sequence[parapy.core.basetype.basetype]
    type = Input(validator=Sequence_type_validator)

    #: the number of members in this sequence. If :attr:`type` is a sequence,
    #: this value can be None
    #: :type: int | typing.Sequence[int] | None
    quantify = Input(None, validator=_quantify_validator)

    #: if True, this instance will not be shown in the GUI tree.
    #: :type: bool
    hidden = Input(False)

    #: name to display in the tree or repr. If ``None``, *role* (name of @Part
    #: definition) is displayed.
    #: :type: str | None
    label = Input(None)

    #: Either a valid string from parapy.globals.X11_COLORS or a 3-integer
    #: iterable with RGB values. RGB ranges 0-255. For example [255,192,203] is
    #: a list.
    #: :type: str | collections.Sequence[int, int, int]
    color = Input("yellow", defaulting=True)

    #: User-settable dictionary with values that control the appearance of this
    #: node in the GUI tree. Valid options::
    #:
    #:     {"label": str (defaults to label slot),
    #:      "color" : bool | str / tuple (defaults to None),
    #:      "background_color" : bool | str | tuple (defaults to (-1, -1, -1)),
    #:      "icon" : path (defaults to self.__icon__),
    #:      "bold" : bool (defaults to False)}
    #:
    #: color values:
    #:
    #: - None: don't color tree node
    #: - True: take on same color as self.color
    #: - str: named color that will be converted to corresponding RGB tuple
    #: - tuple: RGB color
    #:
    #: :type: dict
    tree_style = Input({})

    class _PrevState:
        """Proxy used inside :meth:`Sequence.update_members`"""

        __slots__ = ['type', 'quantify', '_list']

        def __init__(self, members, sequence):
            self.set(members, sequence)

        def set(self, members, sequence):
            """Set the values of this PrevState"""
            # TODO (PP): discuss the need for type_list
            self.type = sequence.type
            self.quantify = sequence.quantify
            # self.type_list = sequence.type_list
            self._list = members

        def __eq__(self, other):
            """
            :param Sequence other: actual Sequence instance
            """
            # If type and quantity are the same, _list cannot be changed
            return self.type == other.type and self.quantify == other.quantify

    @Attribute
    def any(self):
        return AnyProxy(self)

    @Attribute
    def type_list(self):
        """list of base classes. Can be a nested list."""
        type_ = self.type
        if isinstance(type_, basetype):
            quantify = self.quantify
            if isinstance(quantify, int):
                return [type_] * quantify
            elif (hasattr(quantify, "__iter__") and
                  all(isinstance(s, int) for s in quantify)):
                lst = type_
                for quantify in reversed(quantify):
                    lst = [lst] * quantify
                return lst
        else:
            return type_

    @Attribute
    def _list(self) -> List[AbstractBase]:
        """The list with instances that this Sequence object wraps"""
        prev_state = self._prev_state
        if prev_state:
            members = self._diff_update_list(prev_state)
            prev_state.set(members, self)
        else:  # first time
            members = self._create_all_members()
            self._prev_state = self._PrevState(members, self)
        return members

    def _diff_update_list(self, prev_state):
        """Return _list, taking a diff with ``prev_state`` into account.

        :param prev_state: snapshot of previous Sequence state
            with keys like 'type', 'quantify' and '_list'
        """
        prev_quantify = prev_state.quantify
        prev_type = prev_state.type
        prev_list = prev_state._list

        type_ = self.type
        if not isinstance(type_, basetype):
            # no diff implemented when quantifying through type explicitly
            return self._create_all_members()

        quantify = self.quantify
        if hasattr(quantify, '__iter__'):
            # no diff implemented for multi-dimensional Sequences
            return self._create_all_members()

        if type_ is not prev_type or prev_quantify == 0:
            return self._create_all_members()

        if quantify < prev_quantify:
            del prev_list[quantify:]  # remove last members
        else:  # quantify > previous.quantify: create and compose new members
            new_members = make_list(self.type_list[prev_quantify:])
            prev_last = prev_list[-1]
            self._compose_new_members(new_members, prev_last)
            prev_list.extend(new_members)

        return prev_list

    def _compose_new_members(self, objects, previous=None):
        """Create parent-child relations between this Sequence's parent
        and ``objects``.

        .. ATTENTION:: will only work for a 1D Sequence
        """
        # FIXME next not updated for previous member
        # FIXME next not set correctly for new members
        parent = self._parent
        slot = self._slot
        start = previous.index + 1 if previous else 0

        i_max = len(objects) - 1
        for i, obj in enumerate(objects, start):
            next_ = objects[i + 1] if i < i_max else None
            child_ctx = SequenceContext(_index=i, _previous=previous,
                                        _next=next_, _aggregate=self)
            obj._make_child(parent, slot, child_ctx)
            previous = obj

    def _create_all_members(self):
        members = make_list(self.type_list)
        make_children(self, members)
        return members

    @Attribute
    def _data(self):
        type_ = self.type
        if isinstance(type_, basetype):
            # we are a non-jagged, 'complete' matrix
            qtfy = self.quantify
            if hasattr(qtfy, '__iter__'):
                num_items = reduce(operator.mul, self.quantify)
                size = list(qtfy)
            else:
                num_items = qtfy
                size = [qtfy]
            return num_items, len(size), size
        else:
            # we could be a jagged array, we need to walk all the elements
            # to be sure of our num_items, dimensions and sizing
            return _find_iter_len_dim_size(type_)

    @staticmethod
    def _is_not_list(obj):
        return not isinstance(obj, list)

    @Attribute
    def first(self):
        """First item of this Sequence or ``None`` if it is empty"""
        return next(iflatten(self._list, is_atomic=self._is_not_list), None)

    @Attribute
    def last(self):
        """last item of this Sequence or ``None`` if it is empty"""
        lst = self._list

        if isinstance(self.type, basetype):
            qtfy = self.quantify
            if hasattr(qtfy, '__iter__') and all(num > 0 for num in qtfy):
                # we assume that _list and all its sublists are lists
                while isinstance(lst, list) and lst:
                    lst = lst[-1]
                return lst
            elif qtfy != 0:
                return lst[-1]
            else:  # empty list
                return None
        else:
            return _find_last_nested_list(lst)

    @Attribute
    def number_of_items(self):
        """Total number of items in this sequence (flat)"""
        return self._data[0]

    @Attribute
    def dimension(self):
        """Dimension of the sequence. Standard list is dimension 1"""
        return self._data[1]

    @Attribute
    def size(self):
        """Size. 1D list of 4 items --> [4].
        2D list of 3x4 items --> [3,4], etc.
        """
        size = self._data[2]
        if size is None:
            msg = ("Could not calculate the size of the Sequence, it is a "
                   "jagged array: not all the elements of this Sequence have "
                   "the same dimension or size. Object: {!r}")
            raise RuntimeError(msg.format(self))
        else:
            return size

    def sum(self, attr, start=0):
        """Sum all member values corresponding to attribute ``attr``. Usage:

        >>> from parapy.core import *
        ...
        ... class Parent(Base):
        ...     @Part
        ...     def sequence(self):
        ...         return Child(quantify=3,
        ...                      width=child.index + 1)
        ...
        ... class Child(Base):
        ...     width = Input()
        ...
        >>> obj = Parent()
        >>> obj.sequence.sum("width")
        6

        :param str attr: name of attribute to sum.
        :param float start: optional start value.
        :rtype: float
        """
        return start + sum_list(self._list, attr)

    def map(self, attr, processes=1):
        """Use multi-processing to get the values of individual members in
        this sequence.

        :param str attr: name of attribute to get.
        :param int processes: number of Python processes to spawn
        """
        if processes == 1:
            return list(map(attrgetter(attr), self._list))
        else:
            p = mp.Pool(processes)
            result = p.map(getattr_proxy(attr), self._list)
            p.close()
            p.join()
            return result

    def __getitem__(self, idx):
        """customized __getitem__ to allow nested item retrieval like
        ``sequence[1, 2, 3]`` instead of ``sequence[1][2][3]``"""
        if isinstance(idx, tuple):
            return reduce(getitem, idx, self._list)
        else:
            return self._list[idx]

    def __len__(self):
        return len(self._list)

    def __iter__(self):
        return iter(self._list)

    def __reversed__(self):
        return reversed(self._list)

    def __add__(self, other):
        """Convenience override. Allows addition of sequences and other
        iterable types.
        """
        if isinstance(other, list):
            return list.__add__(self._list, other)
        elif isinstance(other, Sequence):
            return list.__add__(self._list, other._list)
        else:
            return NotImplemented

    def __radd__(self, other):
        """Convenience override. Allows addition of sequences and lists"""
        if isinstance(other, list):
            return list.__add__(other, self._list)
        elif isinstance(other, Sequence):
            return list.__add__(other._list, self._list)
        else:
            return NotImplemented

    # TODO RvD: is this one necessary?
    def __contains__(self, item):
        return item in self._list


class MutableSequence(Sequence):
    """Special Sequence that can be mutated at runtime.

    Mutation can be performed with .append(), .insert(), .pop(), and .remove().
    Sequence also resizes dynamically on quantify change keeping existing
    members alive.

    .. ATTENTION:: only support 1-Dimensional data structures.
    """

    _LIST_ATTR = "_list"

    #: a type (Base or subclass of Base)
    type: basetype = Input(validator=IsInstance(basetype))

    #: the number of members in this sequence.
    quantify: int = Input()

    def _create_all_members(self) -> List['Base']:
        members = make_list(self.type_list)
        self._compose_new_members(members)
        return members

    def append(self, obj: 'Base') -> None:
        """Append object to the end of the Sequence."""
        self.insert(len(self), obj)  # insert in last place

    def insert(self, index: int, obj: 'Base') -> None:
        """Insert object in Sequence before index.

        :raises TypeError: type of object does not match type of Sequence
        :raises ValueError: object is already in Sequence
        :raises ValueError: object already has a parent
        """
        if not isinstance(obj, self.type):
            raise TypeError(f"Cannot add object of type {type(obj)} to "
                            f"a sequence with type {self.type}. Make sure "
                            f"the object to insert is of the same type as "
                            f"this Sequence. Object: {object}, Sequence: "
                            f"{self}")
        if obj in self._list:
            raise ValueError(f"Cannot add object {obj} to sequence, it "
                             f"already exists in sequence. Consider using "
                             f"the object from this Sequence or remove the "
                             f"object from the Sequence before adding it."
                             f"Object: {object}, Sequence: {self}")
        if obj.parent:
            raise ValueError(f"Cannot add object {obj} to sequence since it "
                             f"already has a parent. Make sure the object has "
                             f"no parent before adding it to a Sequence. "
                             f"Object: {object}, Sequence: {self}")

        members = self._list
        previous = self._find_previous_object(index)
        members.insert(index, obj)
        self._compose_new_members([obj], previous)
        if previous:  # update `next` of previous
            previous._sequence_context._next = obj

        # set next of new object
        next_index = obj.index + 1
        try:
            next_ = members[next_index]
        except IndexError:  # new object is added at tail
            next_ = None
        obj._sequence_context._next = next_

        members_to_update = members[next_index:]  # update following objects
        self._update_contexts(members_to_update, obj)

        # increase quantity and update prev_state
        cache = self.get_cache(self._LIST_ATTR)
        # prevent _list from invalidating to avoid reconstruction
        with CacheLock([cache]):
            self.quantify += 1

        self._prev_state.set(members, self)
        self.invalidate_dependants(self._LIST_ATTR)

    def _find_previous_object(self, index: int) -> Optional[AbstractBase]:
        """Find previous object to use for composing new member."""
        members = self._list
        if index == 0:  # Inserting as first element
            previous = None
        elif index < 0:
            try:
                previous = members[index - 1]
            # Inserting as first element or at index out of bounds,
            # prepend object
            except IndexError:
                previous = None
        else:  # index > 0
            try:
                previous = members[index - 1]
            except IndexError:  # inserting after the end of the list
                if members:
                    previous = members[-1]
                else:  # empty list case (index - 1 == 0)
                    previous = None

        return previous

    def remove(self, obj: 'Base') -> None:
        """Remove object from Sequence."""
        members = self._list
        index = members.index(obj)
        self.pop(index)

    def pop(self, index: int = -1) -> 'Base':
        """Pop object from Sequence at index."""
        members = self._list
        obj = members.pop(index)

        # update all members when the first element is removed
        members_to_update = members if index == 0 else members[index - 1:]
        try:
            previous = members_to_update[0].previous
        except IndexError:  # no members to update, empty list
            previous = None
        else:
            if previous is obj:  # obj was first element
                previous = None

        self._update_contexts(members_to_update, previous)

        # decrease quantity and update prev_state
        if self.quantify == 0:
            raise RuntimeError(f"Cannot decrement an empty sequence. "
                               f"Object: {self}")

        # prevent invalidation of _list to ensure it is not rebuild
        cache = self.get_cache(self._LIST_ATTR)
        # prevent _list from invalidating to avoid reconstruction
        with CacheLock([cache]):
            self.quantify -= 1

        self._prev_state.set(members, self)
        self.invalidate_dependants(self._LIST_ATTR)
        self.reset_composition_properties(obj)

        return obj

    @staticmethod
    def reset_composition_properties(obj: AbstractBase):
        """Reset composition properties of object."""
        obj._parent = None
        obj._root = None
        obj._slot = None
        obj._tree_level = None
        obj._sequence_context = NO_SEQUENCE_CONTEXT

    @staticmethod
    def _update_contexts(objects: List[AbstractBase],
                         previous: Optional[AbstractBase]) -> None:
        """Update the sequence contexts of `objects`."""
        members = iter(objects)
        obj = next(members, None)
        i = previous._sequence_context._index + 1 if previous else 0
        while obj:
            assert obj._sequence_context, "should have a child context"
            next_ = next(members, None)

            ctx = obj._sequence_context
            ctx._index = i
            ctx._previous = previous
            ctx._next = next_

            previous = obj
            obj = next_
            i += 1

    # TODO DRY from superclass, only Context class has changed
    def _compose_new_members(self, objects, previous=None) -> None:
        """Create parent-child relations between this Sequence's parent
        and ``objects``.

        .. ATTENTION:: will only work for a 1D Sequence
        """
        if not objects:
            return

        parent = self._parent
        slot = self._slot
        start = previous.index + 1 if previous else 0

        i_max = len(objects) - 1
        for i, obj in enumerate(objects):
            next_ = objects[i + 1] if i < i_max else None
            child_ctx = MutableSequenceContext(_index=i + start,
                                               _previous=previous,
                                               _next=next_,
                                               _sequence=self)
            obj._make_child(parent, slot, child_ctx)
            previous = obj


# TODO: optimize for dependency tracking purposes only
class MutableSequenceContext(SequenceContextBase, AbstractBase):
    __initargs__ = ("_index", "_previous", "_next", "_aggregate")
    _index: int = Input()
    _previous: 'Base' = Input()
    _next: 'Base' = Input()
    _sequence: 'MutableSequence' = Input()

    @Attribute
    def _aggregate(self) -> 'MutableSequence':
        sequence = self._sequence
        sequence.touch_slot('_list')
        return sequence


PartParser.SEQUENCE_TYPE = Sequence
AbstractBase.SEQUENCE_TYPE = Sequence


# =============================================================================
# Proxies
# =============================================================================
class AnyProxy(object):
    """
    Object that can be used inside sequence to obtain similar attributes of all sequence items
    in one expression. For example::

        class MyClass(Base):

            lengths = Attribute([1,2,3])

            @Part
            def boxes(self):
                return Box(quantify=len(self.lengths),
                           map_down="lengths->length")

    >>> boxes = MyClass().boxes
    <Sequence (1x3) root.boxes at ...>
    >>> boxes.any.length
    (1, 2, 3)
    >>> boxes.any(processes=1).length
    (1, 2, 3)
    """

    def __getstate__(self):
        return dict((k, getattr(self, k)) for k in ["processes", "sequence", "_reset_after"])

    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

    def __init__(self, sequence):
        self.processes = None
        self.sequence = sequence
        self._reset_after = True

    def __getattr__(self, name):
        if self.processes is None:
            return getattr_tup(self.sequence._list, name)
        else:
            p = mp.Pool(processes=self.processes)
            result = p.map(getattr_proxy(name), self.sequence._list)
            p.close()
            p.join()

            if self._reset_after:
                self.processes = None
            return result

    #     def __call__(self, *args):
    #         f = attrgetter(*args)
    #         return _getattr_tup(self.sequence._list, f)

    def __call__(self, processes=None, reset_after=True):
        self.processes = processes
        self._reset_after = reset_after
        return self


class getattr_proxy(object):
    """This class is a proxy around getattr, which can be pickled and, thus, used inside
    multiprocessing environments.
    """

    def __init__(self, name):
        self.name = name

    def __call__(self, obj):
        return getattr(obj, self.name)


# ---- Utilities ----
def make_list(type_list):
    if isinstance(type_list, basetype):
        return type_list()
    else:
        # for __iter__
        return list(map(make_list, type_list))


def make_children(sequence, objs):
    parent = sequence._parent
    slot = sequence._slot
    _make_children(objs, parent, slot, sequence)
    return objs


def _make_children(obj, parent, slot, sequence, indices=[], previous=None,
                   next=None):
    if isinstance(obj, AbstractBase):
        child_ctx = SequenceContext(_index=indices, _previous=previous,
                                    _next=next, _aggregate=sequence)
        obj._make_child(parent, slot, child_ctx)
    elif hasattr(obj, '__iter__'):
        for index, subchild in enumerate(obj):
            _make_children(subchild, parent, slot, sequence,
                           indices=indices + [index],
                           previous=None if index == 0 else obj[index - 1],
                           next=None if index == len(obj) - 1 else obj[
                               index + 1])


def sum_list(tup, name):
    f = attrgetter(name)
    return _sum_list(tup, f)


def _sum_list(tup, f):
    if isinstance(tup, list):
        return sum((_sum_list(sub, f) for sub in tup))
    else:
        return f(tup)


def getattr_tup(tup, name):
    f = attrgetter(name)
    return _getattr_tup(tup, f)


def _getattr_tup(tup, f):
    if isinstance(tup, list):
        return [_getattr_tup(sub, f) for sub in tup]
    else:
        return f(tup)


def _find_iter_len_dim_size(it):
    num_items = 0
    my_len = 0
    dim = 0
    found_size = []  # will be set to None when it is a jagged array
    for obj in it:
        if isinstance(obj, Iterable):
            nested_num, nested_dim, nested_size = _find_iter_len_dim_size(obj)
            num_items += nested_num
            dim = max(nested_dim, dim)

            if found_size is not None:
                # so far, we have no reason to believe we are a jagged array
                if not found_size:
                    found_size = nested_size
                elif found_size != nested_size:
                    # we already found a size, but it is not the same
                    # size as the one we found now: jagged array
                    found_size = None
        else:
            num_items += 1

        my_len += 1

    if found_size is None:
        size = None  # jagged array: we do not know
    else:
        size = [my_len] + found_size

    return num_items, dim + 1, size


def _find_last_nested_list(lst):
    for obj in reversed(lst):
        if isinstance(obj, list):
            last = _find_last_nested_list(obj)
            if last is not None:
                return last
        else:
            return obj

    return None
