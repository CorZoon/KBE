#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import typing
from functools import partial
from logging import warning

import wx

from parapy.core import apply_to_all
from parapy.geom.generic.positioning import Position
from parapy.geom.generic.transformation import Transformation
from parapy.geom.occ.transform import get_transformation, transform_position
from parapy.gui import wx34
from parapy.gui.actions import ViewerSelectionContext
from parapy.gui.manipulation.events import (
    EndEvent, MotionEvent, create_end_event, create_motion_event)
from parapy.gui.manipulation.gizmo import GizmoBase
from parapy.gui.manipulation.transformation import TransformationState
from parapy.gui.manipulation.viewer_facades import (
    GhostViewerFacade, GizmoViewerFacade)

if typing.TYPE_CHECKING:
    from OCC.gui.viewer import Viewer as OCCViewer
    from parapy.gui.manipulation.modes import ManipulationMode
    from parapy.gui.manipulation.gizmo import GizmoBase
    from parapy.core.abstract import DrawableParaPyObject
    from parapy.core import Base
    from parapy.gui.viewer import Viewer

__all__ = "Manipulation"


class ManipulationActiveError(RuntimeError):
    """raised if you try to activate a manipulation on an object that is
    already being manipulated
    in the same viewer"""
    pass


class Manipulation:
    """Class to manage the lifecycle of a manipulation of an object in a viewer.
    When `.start()`ed, it hijacks the viewer's click event handling on the gizmo
    handles to manipulate the object. When `.stop()`ped, it will give back the
    control to the viewer.

    The `on_motion`, `on_submit`, `on_cancel` callbacks will receive events
    to give the user some programmatic introspection on the manipulation state
    and also some limited way of interfering with in (in the on_motion case).

    If a ghost is present, it will be dragged along in lieu of the object when
    manipulating it.
    """

    DRAG_INSTRUCTION_MSG = "Drag the Manipulator..."
    INSTRUCTION_MSG = (DRAG_INSTRUCTION_MSG +
                       " Press ENTER/RETURN to submit or ESCAPE to cancel.")

    def __init__(self,
                 obj: 'Base',
                 viewer: 'Viewer',
                 gizmo: 'GizmoBase',
                 ghost: typing.Union['Base', 'DrawableParaPyObject'] = None,
                 suppress_guide_shapes: bool = False,
                 reference_position: typing.Optional[Position] = None,
                 on_submit: typing.Callable[[EndEvent], None] = None,
                 on_cancel: typing.Callable[[EndEvent], None] = None,
                 on_motion: typing.Callable[[MotionEvent], None] = None,
                 on_setup: typing.Callable[['Viewer'], None] = None,
                 on_teardown: typing.Callable[['Viewer'], None] = None):
        """
        :param parapy.core.Base obj: the object being manipulated.
        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation takes place.
        :param parapy.core.gui.manipulation.gizmo.Gizmo gizmo: the manipulator
            that the user can interact with to manipulate the object. The gizmo
            determines 'how' the object can be manipulated (via the
            ManipulationModes it is constructed from).
        :param parapy.core.abstract.DrawableParaPyObject ghost:
            The 'ghost' that is dragged along with the gizmo. Defaults
            to `obj` One can specify any object to act as a ghost.
            If set to self, the manipulable object itself (its visual part)
            will move. Set the ghost to :py:`None` and only the gizmo will
            move in the viewer until the manipulation is done.
            .. caution:: the ghost should not be updated/changed when
                the manipulation :attr:`is_active`.
        :param suppress_guide_shapes:
            Whether guides should be shown or not; overrides individual per-mode
            settings.
        :param reference_position:
            The :class:`~parapy.geom.Position` that is used as a reference
            for the Manipulation (it will show the start and final position
            relative to this position).
            It is useful when the position of the Manipulable object does not
            give a good representation of where the shape itself is located (for
            instance when using shapes resulting from a Boolean operation).
        :param on_submit:
            Callback that receives an EndEvent when the user finishes a
            manipulation, by submitting it (press Enter).
        :param on_cancel:
            Callback that receives an EndEvent when the user finishes a
            manipulation by cancelling it (press Esc).
        :param on_motion:
            Callback that receives MotionEvent instances throughout the
            manipulation, while the user is dragging a gizmo handle.
        :param on_setup:
            Callback fired before the manipulation is started.
        :param on_teardown:
            Callback fires after the manipulation is submitted or cancelled.

        """
        self._on_setup = on_setup
        self._on_teardown = on_teardown
        self._obj = obj
        self._viewer = viewer
        self._occ_viewer: "OCCViewer" = viewer._occ_viewer
        self._mode: typing.Optional['ManipulationMode'] = None
        self._main_window = viewer.GetTopLevelParent()
        self._ghost = ghost
        self._gizmo = gizmo

        reference_pos = reference_position or obj.position

        self.initial_reference_position = reference_pos
        self.current_reference_position = reference_pos

        manipulator_pos = gizmo.position

        self.initial_manipulator_position = manipulator_pos

        self.manipulator_to_reference_trsf = man_to_ref_trsf = \
            get_transformation(
                self.initial_manipulator_position,
                self.initial_reference_position)

        self.reference_to_manipulator_trsf = man_to_ref_trsf.Inverted()
        # set transformation state
        self._trsf_state = TransformationState(viewer)

        # --- GUIDES ---
        self._suppress_guide_shapes = suppress_guide_shapes
        self._ais_guide_shapes = []

        # keeps track of previous intermediate positions between drags
        self._manipulator_position_history = [self.current_manipulator_position]
        # receives manipulation events
        self._on_motion = on_motion
        self._on_submit = on_submit
        self._on_cancel = on_cancel

        self._last_trsf = None

        self._gizmo_facade = GizmoViewerFacade(gizmo, viewer)

        if ghost:
            self._ghost_facade = GhostViewerFacade(ghost, viewer)
        else:
            self._ghost_facade = None

        # the saved window_state
        self._gui_state = None

        self.is_active = False

    @property
    def status_bar(self):
        main_window = self._viewer.GetTopLevelParent()
        return main_window.GetStatusBar()

    def _disable_window(self):
        main_window = self._main_window
        self._save_window(main_window)

        main_window.data_panel.Disable()
        main_window.tree_panel.Disable()
        self._viewer.toolbar.wx_toolbar.EnableTool(
            self._viewer.toolbar.btn_delete_all.GetId(), False)

    def _save_window(self, main_window):
        toolbar = self._viewer.toolbar

        state = {
            'data': main_window.data_panel.IsEnabled(),
            'tree': main_window.data_panel.IsEnabled(),
            'delete_button': toolbar.wx_toolbar.GetToolEnabled(
                toolbar.btn_delete_all.GetId())
        }
        self._gui_state = state

    def _restore_window(self):
        toolbar = self._viewer.toolbar

        state = self._gui_state

        if state is None:
            msg = ("Cannot restore window state before the state was saved "
                   "using _save_window. Object: {!r}")
            raise RuntimeError(msg.format(self))

        main_window = self._main_window
        main_window.data_panel.Enable(state['data'])
        main_window.tree_panel.Enable(state['tree'])
        toolbar.wx_toolbar.EnableTool(toolbar.btn_delete_all.GetId(),
                                      state['delete_button'])

    def context(self):
        """Return a context manager that is used to put setup GUI in
        for selection and restores GUI when done. Can be overridden in
        subclasses.
        """
        return ViewerSelectionContext(self._main_window)

    def to_reference_axis_system(self, pos):
        """apply to pos the same transformation necessary to transform
        the initial gizmo position to the initial reference position.
        """
        return transform_position(pos,
                                  self.initial_manipulator_position,
                                  self.manipulator_to_reference_trsf)

    def to_manipulator_axis_system(self, pos):
        """apply to pos the same transformation necessary to transform
        the initial reference position to the initial gizmo position.
        """
        return transform_position(pos,
                                  self.initial_reference_position,
                                  self.reference_to_manipulator_trsf)

    @property
    def current_manipulator_position(self):
        return self._gizmo.position

    @current_manipulator_position.setter
    def current_manipulator_position(self, pos):
        self._gizmo.position = pos

    def display(self, update=True):
        ghost_facade = self._ghost_facade

        if ghost_facade:
            ghost_facade.display(update=False)

        self._gizmo_facade.display(update=update)

    def transform(self, new_man_pos, new_reference_pos):
        # update the position of gizmo and ghost
        ghost_facade = self._ghost_facade
        self._gizmo_facade.transform(
            self.initial_manipulator_position, new_man_pos,
            update=False)

        if ghost_facade:
            ghost_facade.transform(
                self.initial_reference_position, new_reference_pos,
                update=False)

        self._update_guides(new_man_pos)

        self.current_manipulator_position = new_man_pos
        self.current_reference_position = new_reference_pos

        # update once after all is done
        self._viewer.update()

    def remove(self, update=True):
        if self._ghost:
            self._ghost_facade.remove(update=update)
            self._ghost_facade = None

        self._gizmo_facade.remove(update=update)
        self._gizmo_facade = None

    def start(self):
        if self.is_active:
            msg = f"manipulation on {self._obj} already active."
            raise ManipulationActiveError(msg)
        if self._on_setup:
            self._on_setup(self._viewer)
        self._setup()
        self.is_active = True

    def _setup(self):
        self._disable_window()
        self._disable_occ_viewer_selection()

        self.display()
        self._viewer._manipulations.add(self)

        # bind events
        self._bind_drag_start_stop()
        self._bind_submit_cancel()

        # set instruction text
        status_bar = self.status_bar
        if status_bar:
            status_bar.PushStatusText(self.INSTRUCTION_MSG)

    def _disable_occ_viewer_selection(self):
        occ_viewer = self._occ_viewer

        occ_viewer.unhighlight_all(False)
        occ_viewer.deselect_all(False)

        self._viewer.deactivate_selection_mode() # deactivates all

    def _restore_occ_viewer_selection(self):
        self._viewer.activate_selection_mode(0) # reactivates all

    def start_drag(self, x, y, mode, detected_object=None):
        # arrow currently highlighted, remove highlighted presentation
        # it otherwise stays in the screen, but will not follow the arrow
        if detected_object:
            # TODO (PP): investigate how to remove highlighting efficiently
            facade = self._gizmo_facade
            ais_shape = next(ais for ais, pp in facade._ais_shapes_to_pp.items()
                             if pp is detected_object)
            context = ais_shape.GetContext()
            context.Erase(ais_shape, False)
            context.Display(ais_shape, False)

        # start the bookkeeping of the manipulation's calculated position
        trsf_state = self._trsf_state
        current_man_pos = self.current_manipulator_position

        # this mode is already transformed: its reference is current_man_pos
        self._mode = mode
        trsf_state.start_transformation(mode,
                                        current_man_pos,
                                        x, y)

        self._setup_viewer_drag()
        self._setup_guides()

        # events
        self._bind_dragging()
        self._unbind_submit_cancel()

        # print "drag of axis {} started".format(axis)
        status_bar = self.status_bar
        if status_bar:  # update text: submit/cancel not possible
            status_bar.PushStatusText(self.DRAG_INSTRUCTION_MSG)

    def get_previous_reference_position(self):
        previous_man_pos = self._manipulator_position_history[-1]
        return self.to_reference_axis_system(previous_man_pos)

    def _on_transform(self, evt: wx.MouseEvent):
        """Updates position of gizmo, ghost and propagates ManipulationEvents.
        """
        trsf_state = self._trsf_state
        if not trsf_state or not trsf_state.is_active:
            return

        mouse_position = evt.GetX(), evt.GetY()

        # transformation state is relative to the gizmo (gizmo)
        transformed_man_position = trsf_state.get_current_position(
            *mouse_position)
        transformed_ref_position = self.to_reference_axis_system(
            transformed_man_position)

        if not self._on_motion:
            return self.transform(
                transformed_man_position, transformed_ref_position)

        initial_reference_position = self.initial_reference_position
        previous_position = self.get_previous_reference_position()
        event = create_motion_event(
            mouse_position=mouse_position,
            start_position=initial_reference_position,
            previous_position=previous_position,
            current_position=transformed_ref_position,
            mode=trsf_state.mode,
            source=self._viewer,
            transformation=Transformation(initial_reference_position,
                                          transformed_ref_position))

        # allows the (user) event listener to mutate/veto the event
        self._on_motion(event)

        if not event.IsAllowed:
            return

        modified_ref_pos = event.current_position

        if not modified_ref_pos.is_almost_equal(transformed_man_position):
            # user specified a different position (in reference terms):
            # transform it back to gizmo coordinates
            transformed_man_position = self.to_manipulator_axis_system(
                modified_ref_pos)

        self.transform(transformed_man_position, modified_ref_pos)

    def stop_drag(self):
        self._teardown_viewer_drag()

        # remove all ais shapes
        self._remove_guide_shapes()

        # events
        self._unbind_dragging()
        self._bind_submit_cancel()

        self._manipulator_position_history.append(
            self.current_manipulator_position)
        self._trsf_state.stop_transformation()

    def _setup_viewer_drag(self):
        viewer = self._viewer
        viewer.SetCursor(wx34.Cursor(wx.CURSOR_SIZING))

    def _setup_guides(self):
        if self._suppress_guide_shapes or not self._mode.show_guide:
            return

        occ_viewer = self._occ_viewer
        self._ais_guide_shapes = ais_objs = self._mode.create_guides(
            start_pos=self.initial_manipulator_position,
            previous_pos=self.get_previous_reference_position(),
            current_pos=self._gizmo.position,
            scale=self._gizmo.size)

        for ais_obj in filter(None, ais_objs):
            occ_viewer.display(ais_obj, fit=False)

    def _update_guides(self, current_man_pos):
        ais_guide_shapes = self._ais_guide_shapes
        if not ais_guide_shapes:
            return

        previous_man_pos = self.to_manipulator_axis_system(
            self.get_previous_reference_position())

        updates = self._mode.update_guides(
            ais_guide_shapes,
            self.initial_manipulator_position,
            previous_man_pos,
            current_man_pos)

        if not updates:
            # nothing to be done; no update was done by the user OR
            # the user did implement an _update_guides method,
            # but there are no updates to process (everything was done in-place)
            return

        viewer = self._occ_viewer
        # else: the user has returned an iterable of ais shape pairs, to replace
        # the old shapes individually (or some of them)
        for old, new in updates:
            if old:
                viewer.hide(old, update=False, fit=False)
                ais_guide_shapes.remove(old)
            if new:
                viewer.display(new, update=False, fit=False)
                ais_guide_shapes.append(new)

        self._ais_guide_shapes = ais_guide_shapes

    def _teardown_viewer_drag(self):
        viewer = self._viewer
        viewer.SetCursor(wx34.Cursor(wx.CURSOR_ARROW))

    def _remove_guide_shapes(self):
        if self._suppress_guide_shapes or not self._ais_guide_shapes:
            return
        remover = partial(self._occ_viewer.remove, fit=False)
        apply_to_all(remover, filter(None, self._ais_guide_shapes))
        self._ais_guide_shapes = []

    # binding events
    def _bind_submit_cancel(self):
        occ_viewer = self._occ_viewer
        occ_viewer.Bind(wx.EVT_KEY_UP, self._on_key_up)

    def _unbind_submit_cancel(self):
        occ_viewer = self._occ_viewer
        occ_viewer.Unbind(wx.EVT_KEY_UP, handler=self._on_key_up)

    def _bind_drag_start_stop(self):
        occ_viewer = self._occ_viewer
        occ_viewer.Bind(wx.EVT_LEFT_DOWN, self._on_left_down)
        occ_viewer.Bind(wx.EVT_LEFT_UP, self._on_left_up)

    def _unbind_drag_start_stop(self):
        occ_viewer = self._occ_viewer
        occ_viewer.Unbind(wx.EVT_LEFT_DOWN, handler=self._on_left_down)
        occ_viewer.Unbind(wx.EVT_LEFT_UP, handler=self._on_left_up)

    def _bind_dragging(self):
        occ_viewer = self._occ_viewer
        occ_viewer.Bind(wx.EVT_MOTION, self._on_transform)

    def _unbind_dragging(self):
        occ_viewer = self._occ_viewer
        occ_viewer.Unbind(wx.EVT_MOTION, handler=self._on_transform)

    def _on_key_up(self, evt):
        key = evt.KeyCode
        if key == wx.WXK_ESCAPE:
            return self.end(submitted=False)
        elif key in (wx.WXK_NUMPAD_ENTER, wx.WXK_RETURN):
            return self.end(submitted=True)
        elif key == ord('Z') and evt.controlDown:
            # undo on ctrl+z
            return self.undo_last_transformation()
        else:
            evt.Skip()

    def undo_last_transformation(self):
        if not len(self._manipulator_position_history) > 1:
            warning('history too short: cannot undo')
            return

        self._manipulator_position_history.pop()
        gizmo_pos = self._manipulator_position_history[-1]

        self.current_manipulator_position = gizmo_pos
        ref_pos = self.to_reference_axis_system(gizmo_pos)

        self.transform(gizmo_pos, ref_pos)

    def end(self, submitted: bool):
        initial_position = self.initial_reference_position
        final_position = self.current_reference_position
        viewer = self._viewer

        evt_listener = self._on_submit if submitted else self._on_cancel
        if evt_listener:
            manipulation_done_evt = create_end_event(
                start_position=initial_position,
                current_position=final_position,
                source=viewer,
                submitted=submitted,
                transformation=Transformation(initial_position,
                                              final_position)
            )
            evt_listener(manipulation_done_evt)

        self._teardown()
        if self._on_teardown:
            self._on_teardown(viewer)
        self.is_active = False

    def _teardown(self):
        self._unbind_drag_start_stop()
        self._unbind_submit_cancel()

        self.remove(update=False)
        viewer = self._viewer
        viewer._manipulations.remove(self)
        del self._gizmo.position  # restore dependency tracking

        viewer.refresh(update=True)
        self._restore_window()
        self._restore_occ_viewer_selection()

        status_bar = self.status_bar
        if status_bar:  # update text: previous message
            status_bar.PopStatusText()

    def _on_left_up(self, evt):
        trsf_state = self._trsf_state
        if trsf_state and trsf_state.is_active:
            self.stop_drag()
        else:
            evt.Skip()

    def _on_left_down(self, evt):
        viewer = self._viewer
        detected = viewer.detected
        if not detected:
            evt.Skip()
            return

        detected_object = detected[0]
        # check if the detected shape is any of the gizmo's handles
        mode = self._gizmo.interactive_shape_to_manipulation_mode(
            detected_object)

        if mode is None:
            evt.Skip()
            return

        trsf_state = self._trsf_state
        if not (trsf_state and trsf_state.is_active):
            viewer.SetFocus()
            self.start_drag(evt.x, evt.y, mode,
                            detected_object=detected_object)
            return
        evt.Skip()
        return
