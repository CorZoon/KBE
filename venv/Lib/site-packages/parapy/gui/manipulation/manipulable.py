#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import logging
import typing

from parapy.core import (
    DynamicType, HiddenPart, Input, action, on_event, Attribute)
from parapy.core.widgets import MultiCheckBox, CheckBox
from parapy.geom import GeomBase, Vector
from parapy.gui import get_top_window
from parapy.gui.events import EVT_RIGHT_CLICK_OBJECT
from parapy.gui.manipulation.events import (
    EndEvent, ManipulationEvent, MotionEvent)
from parapy.gui.manipulation.gizmo import Gizmo, GizmoBase
from parapy.gui.manipulation.globs import DEFAULT_AXES, XYZ_COMPONENT_COLORS
from parapy.gui.manipulation.manipulation import Manipulation
from parapy.gui.manipulation.modes import (
    Translation, PlanarTranslation, Rotation,
    ManipulationMode)
from parapy.gui.menus import ContextMenu

__all__ = "Manipulable", "ManipulableBase"


class ManipulableBase(GeomBase):
    """Mixin to make a Shape manipulable in the viewer.
    Only works when mixing this class in with a shape that inherits from
    :class:`~parapy.geom.occ.drawable.DrawableShape`.

    By default manipulation can be started via an action (visible in the gui
    as a button in the propgrid) OR via right-clicking the object in the viewer
    and selecting 'Manipulate'.

    After the manipulation has been started, the user can drag-drop the gizmo's
    handles in the viewer to transform the objects' position in the viewer. The
    idea is: everything that happens to the gizmo happens 1:1 to the object
    being manipulated.

    Pressing Enter will submit the manipulation and pressing Esc will cancel it.
    In the first case, the :meth:`on_submit` will be called; otherwise
    :meth:`on_cancel` will. Typically, you'll want to override on_submit and
    update the manipulable object's position with the position that
    the object had when the user submitted the Manipulation.

    The only required input is :attr:`modes`, i.e. the ``ManipulationModes`` in which this
    object can be manipulated.

    >>> from parapy.geom import Cube, Position
    ... from parapy.gui.manipulation import (
    ...     ManipulableBase, EndEvent, Translation, Rotation)
    ...
    ... class MyCube(Cube, ManipulableBase):
    ...     def on_submit(self, evt: EndEvent):
    ...         self.position = evt.current_position
    ...
    >>> # object can be translated along x and y and rotated around z.
    >>> obj = MyCube(dimension=1, modes=[
    ...     Translation('x'), # can be dragged along x
    ...     Translation('y'), # and along y
    ...     Rotation('z') # and rotated around z
    ...     ])

    .. attention:: all directions of manipulation are interpreted relative to
        the (manipulable) object's position. So, named vectors like 'x' are
        refering to the local x-axis of the object, but an explicit
        ``Vector(1, 0, 0)`` as well.

    For convenience, we expose in ``parapy.gui.manipulation`` the basic modes:

    - DEFAULT_AXIS_MODES: translate the object along X, Y and Z
    - PRIMARY_AXIS_PLANAR_TRANSLATIONS: move the object freely on the X, Y and Z planes
    - PRIMARY_AXIS_ROTATIONS: rotate the object around X, Y and Z

    >>> # for example to translate obj can be translated along all 3 primary axes
    >>> from parapy.gui.manipulation import PRIMARY_AXIS_TRANSLATIONS
    >>> obj = MyCube(dimension=1, modes=PRIMARY_AXIS_TRANSLATIONS)

    Alternatively, modes can be *implemented* inside the class
    definition (statically like below or even wrapped inside a slot):

    >>> class ManipulableCube(Cube, ManipulableBase):
    ...     modes = [Translation('x'),
    ...              Translation('y'),
    ...              Rotation('z')]
    ...
    ...     def on_submit(self, evt: EndEvent):
    ...         self.position = evt.current_position
    ...
    ... obj = MyCube(dimension=1)

    Configuration options:
    ======================
    - By default, the gizmo's will be displayed at the same position the object
        being manipulated is. If the :attr:`position` of the object is not a
        good reference for the gizmo (e.g. it gets in the way of other shapes,
        one can specify a different position for it via
        :attr:`gizmo_position`.
    - Change the size of the Manipulator: see :attr:`gizmo_size.
    - Show a different representation of the shape that is being dragged, see
        :attr:`ghost`.
    - Choose whether guide lines should be shown when the gizmo is dragged
        see :attr:`show_guides`. Want more fine-grained control on which mode
        should show guides? Pass them via each ManipulationMode:

    >>> obj = MyCube(1, show_guides=False,
    ...     modes=[
    ...         Translation('y'), # will not show a guide by default
    ...         Translation('x', show_guide=True), # this one will
    ...     ])

    - By default, we color the gizmo handles based on their orientation:
        X becomes red, Y green and Z blue. Want to change that? pass a different
        :attr:`manipulator_xyz_component_colors`. Want even more fine-grained
        control? each ManipulationMode can have its own :attr:`handle_color`:

    >>> obj = MyCube(1, modes=[
    ...     Translation('x', handle_color=(12,150,44)),
    ...     Translation('y', handle_color='black'),
    ...     Rotation('z') # default: blue
    ...     ])
    - Using :attr:`bidirectional_gizmo_arrows` you can choose if the
        gizmo handles for the 'axis' ManipulationMode are facing both
        ways relative to their axis vector (v_<-->v+) or only one ( -->v+).
    - By setting :attr:`zoom_persistent` to True, the gizmo will not scale
        in the viewer like other objects do. Mind that in this case, the
        :attr:`gizmo_size` will mean 'pixels', and not 'world units'.

    Advanced usage/behaviour:
    =========================
    - Set limits to where the Manipulable can move, or override the behavior
        of what should happen when manipulating the object (the position
        it should be actually dragged to, displaying information about the
        manipulation or stopping some kinds of movement from happening), see
        :meth:`on_motion`.
    - Chance to setup the UI before manipulation becomes active
        :meth:`on_setup`, e.g. adjust the camera.
     - Chance to teardown the UI after manipulation ends
        :meth:`on_teardown`, e.g. reset the camera.
    - Provide your own Gizmo by overriding GIZMO_CLS; make sure to conform to
        the GizmoBase interface.
    - If you pass :attr:`rotation_persistent` to a ManipulationMode, the mode
        will keep its global orientation throughout the manipulation.

    >>> # obj can be translated along obj.Vx (even if obj.Vx
    ... #  were to change during manipulation) and Vector(0,1,0)
    ... obj = MyCube(modes=[Translation('x'),
    ...                        Translation('y',
    ...                           rotation_persistent=True)])

        By default, the mode is defined in terms of the position of the
        manipulable object.
        That means, that even if a Mode is rotation pesistent, it remains
        relative to the object's position at the time the manipulation starts.

    >>> # obj can be translated along obj.Vx (even if obj rotates)
    ... # and GLOBAL VX (because 'y' becomes global X in YOZ)
    ... from parapy.geom import YOZ # x is z, y is x
    ... obj = MyCube(position=YOZ,
    ...                 modes=[Translation('x'),
    ...                        Translation('y',
    ...                           rotation_persistent=True)])

        For this reason it is also possible to pass a reference to each
        ManipulationMode: that is, an axis system in which the mode is defined.
        This way, it is possible to reliably transform objects along vectors
        defined in arbitrary axis systems.

    >>> # obj can be translated along obj.Vx and Vector(0,1,0)
    ... obj = MyCube(position=Position().rotate(x=.1),
    ...                 modes=[Translation('x'),
    ...                        Translation('y',
    ...                           reference=Position(),
    ...                           rotation_persistent=True)])

    """

    # which class to use as Gizmo
    GIZMO_CLS: typing.Type[GizmoBase] = Gizmo

    #: how to color the gizmo shapes based on their 'reference' axis components
    manipulator_xyz_component_colors = Input(XYZ_COMPONENT_COLORS)

    #: the manipulation modes in which this object can be manipulated
    modes: typing.Sequence[ManipulationMode] = Input()

    #### ===== arguments for the Gizmo constructor ===== ####
    #: `bidirectional_gizmo_arrows`: If set to :py:`True`,
    #:      the gizmo's Arrows (for Axis manipulation mode) will point
    #:      both ways along the given translation axis. E.g. if
    #:      translation_axes is ['x'], then the Gizmo will have arrows towards
    #:      orientation.Vx and orientation.Vx_.
    #:      If False, only the arrowhead on the 'positive' direction will be
    #:      displayed
    bidirectional_gizmo_arrows = Input(True, widget=CheckBox)

    #: `zoom_persistent`: If set to :py:`True` the size of the gizmo
    # will be defined in
    #:      on-screen pixels and will not resize when zooming. Otherwise the
    #:      gizmo its size will be defined in world-units, and will be
    #:      subjective to zooming.
    # fixme: zoom persistence is currently broken (if zooming out far enough)
    zoom_persistent = Input(False, widget=CheckBox)

    #: show guide lines while manipulating
    #: does not have an effect when users passes his own modes
    show_guides = Input(True, widget=CheckBox)

    @Input
    def gizmo_size(self):
        """Size of the gizmo. If :attr:`zoom_persistent` is :py:`True`,
        this will be the size of the main axes of the gizmo in on-screen
        pixels. If :attr:`zoom_persistent` is :py:`False`, it is the size
        of the main axes in world-units.

        :rtype: int
        """
        if self.zoom_persistent:
            return 60  # seems to be reasonable, in pixels
        return 1

    @Input
    def gizmo_position(self):
        return self.position

    @Input
    def ghost(self):
        """The 'ghost' that is dragged along with the gizmo. Defaults
        to `obj`
        One can specify any :class:`~parapy.core.abstract.DrawableParapyObject`
        that will act as a ghost. If set to self, the manipulable object itself
        will move. Set the ghost to :py:`None` if no shape, apart from the
        gizmo, should move along with the manipulation.

        .. caution:: the ghost should not be updated/changed while the
        manipulation is active."""
        return self

    @HiddenPart
    def gizmo(self):
        return DynamicType(
            type=self.GIZMO_CLS,
            position=self.gizmo_position,
            modes=self.modes,
            bidirectional_arrows=self.bidirectional_gizmo_arrows,
            size=self.gizmo_size,
            xyz_component_colors=self.manipulator_xyz_component_colors,
            zoom_persistent=self.zoom_persistent)

    def _get_event_handler(self, method_name):
        abstract_method = getattr(Manipulable, method_name)
        this_cls_method = getattr(type(self), method_name, None)
        if this_cls_method is abstract_method:
            return None
        return getattr(self, method_name)

    def create_manipulation(self, viewer):
        """
        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation takes place.
        :rtype: Manipulation
        """

        on_motion = self._get_event_handler('on_motion')
        on_submit = self._get_event_handler('on_submit')
        on_cancel = self._get_event_handler('on_cancel')

        if not on_submit:
            logging.warning('you should probably implement (at least) '
                            'on_submit, to register the final'
                            'position once the manipulation is done.')

        return Manipulation(obj=self,
                            viewer=viewer,
                            gizmo=self.gizmo,
                            ghost=self.ghost,
                            reference_position=self.position,
                            on_submit=on_submit,
                            on_cancel=on_cancel,
                            on_motion=on_motion,
                            on_setup=self._on_setup,
                            on_teardown=self._on_teardown)

    def on_motion(self, evt: MotionEvent):
        """While the manipulation is in progress, this handler will periodically
        receive MotionEvents.

           - evt.mouse_position : Position : the position of the mouse at the
                time this event was fired
           - evt.start_position : Position : the reference position of the
                object being manipulated
           - evt.current_position : Position : the current position of the
                object
           - evt.previous_position : Position : the previous position,
                corresponding to the previous event's current_position.
                This allows the user to easily `undo` a
                MotionEvent by rolling back the last change:
                >>> def on_motion(self, evt:MotionEvent):
                ...     evt.current_position = evt.previous_position
                Note: if this event is the first one, the previous_position
                will be equal to start_position (i.e. self.position).
           - evt.transformation : Transformation : a Transformation object that
                encapsulates the transformation from start_position to
                current_position. Ideal if you want to apply the same
                transformation to multiple objects. especially useful if
                RotationManipulationMode is active. Equivalent to translating
                by the vector (evt.current_position-evt.start_position) and then
                applying a rotation matrix corresponding to the rotations that
                start_position has undergone.
           - evt.mode: ManipulationMode: the manipulation mode currently active.
           - evt.source : Viewer: the source of this event; the Viewer in
                which the manipulation is active
        """
        raise RuntimeError("Not intended to be called")

    def on_submit(self, evt: EndEvent):
        """ Called when the manipulation is submitted (i.e. the viewer presses
        Enter while the manipulation is active.

        :param ManipulationEvent evt: The event object has the following
            properties:
            - evt.mode: one of ManipulationMode.rotation/axis/plane
            - evt.transformation_kwargs: depending on which mode the object
                is being manipulated:
                - ManipulationMode.axis: {'axis': Vector}
                - ManipulationMode.plane: {'normal': Vector}
                - ManipulationMode.rotation: {'normal': Vector}
            - evt.start_position: initial position of the manipulable
            - evt.current_position: the position that will be the result of the
                current transformation action, if the default behaviour will be
                allowed. Setting this to a different
                value will cause a transformation from ``start_position` to the
                provided position instead.
            - evt.viewer parapy.gui.viewer.Viewer: viewer in which the
                transformation is taking place
            - evt.transformation: a Transformation object that encapsulates
            the transformation
                  from start_position to current_position. usage:
                >>> def on_end(self, evt: EndEvent, obj):
                ...     if evt.submitted:
                ...         self.position = evt.transformation.apply(
                self.position)
                 especially useful if RotationManipulationMode is active.
                 Ideal if you want
                 to apply the same transformation to multiple objects.
                 Equivalent to first
                 translating by the vector (
                 evt.current_position-evt.start_position) and then
                 applying a rotation matrix corresponding to the rotations
                 that start_position
                 has undergone.
            - evt.submitted: True.
        """
        raise RuntimeError("Not intended to be called")

    def on_cancel(self, evt: EndEvent):
        """ Called when the manipulation is cancelled (i.e. the viewer presses
        Esc while the manipulation is active.

        :param ManipulationEvent evt: The event object has the following
            properties:
            - evt.mode: one of ManipulationMode.rotation/axis/plane
            - evt.transformation_kwargs: depending on which mode the object
                is being manipulated:
                - ManipulationMode.axis: {'axis': Vector}
                - ManipulationMode.plane: {'normal': Vector}
                - ManipulationMode.rotation: {'normal': Vector}
            - evt.start_position: initial position of the manipulable
            - evt.current_position: the position that will be the result of the
                current transformation action, if the default behaviour will be
                allowed. Setting this to a different
                value will cause a transformation from ``start_position` to the
                provided position instead.
            - evt.viewer parapy.gui.viewer.Viewer: viewer in which the
                transformation is taking place
            - evt.transformation: a Transformation object that encapsulates
            the transformation
                  from start_position to current_position. usage:
                >>> def on_end(self, evt: EndEvent, obj):
                ...     if evt.submitted:
                ...         self.position = evt.transformation.apply(
                self.position)
                 especially useful if RotationManipulationMode is active.
                 Ideal if you want
                 to apply the same transformation to multiple objects.
                 Equivalent to first
                 translating by the vector (
                 evt.current_position-evt.start_position) and then
                 applying a rotation matrix corresponding to the rotations
                 that start_position
                 has undergone.
            - evt.submitted: False.
        """
        raise RuntimeError("Not intended to be called")

    def _on_setup(self, viewer):
        """Internal setup: we do our own setup, then call the user-implemented
        on_setup()
        """
        self.is_being_manipulated = True
        user_setup = self._get_event_handler('on_setup')
        if user_setup:
            user_setup(viewer)

    def on_setup(self, viewer):
        """User can override this method to initiate the viewer for the
        Manipulation, like setting a specific camera position, disable parts
        of the gui, or showing hints to the user. See also
        :meth:`on_teardown` for restoring this.

        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation takes place.
        """
        raise RuntimeError("Not intended to be called")

    def _on_teardown(self, viewer):
        """Internal teardown: we do our own teardown, then call the user-implemented
        on_teardown()
        """
        self.is_being_manipulated = False
        user_teardown = self._get_event_handler('on_teardown')
        if user_teardown:
            user_teardown(viewer)

    def on_teardown(self, viewer):
        """Called at the end of the manipulation. It allows the user to
        restore the viewer (if the state was changed for this manipulation in
        :meth:`on_setup`). Keep in mind that also
        `on_motion` will be fired one last time on manipulation
        end; this method is provided for backwards compatibility.

        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation took place.
        """
        raise RuntimeError("Not intended to be called")

    @action(label='manipulate', button_label='manipulate')
    def start(self, viewer=None):
        """Start to make_manipulation this Manipulable object inside
        ``viewer``."""
        viewer = viewer or get_top_window().viewer
        manipulation = self.create_manipulation(viewer)
        manipulation.start()

    is_being_manipulated = False

    @on_event(EVT_RIGHT_CLICK_OBJECT)
    def _on_left_click(self, evt):
        if self.is_being_manipulated:
            return # consume the event

        viewer = evt.source

        def show_display_menu(_evt):
            evt.Skip()

        context_menu = ContextMenu()
        context_menu.append_item("Manipulate", icon='open_with.png',
                                 handler=lambda evt: self.start(viewer))
        context_menu.append_item("Appearance", icon='color_fill.png',
                                 handler=show_display_menu)
        evt.source.PopupMenu(context_menu)


def ensure_vectors(vectors):
    return tuple(map(Vector.ensure_vector, vectors))


class Manipulable(ManipulableBase):
    """Mixin to make an object manipulable in the viewer.
    Adds to ManipulableBase a few inputs to dynamically create the modes, and
    widgets to do so from the property grid in the ui.

    Only works when mixing this class in with a shape that inherits from
    :class:`~parapy.geom.occ.drawable.DrawableShape`.

    By default manipulation can be started via an action (visible in the gui
    as a button in the propgrid) OR via right-clicking the object in the viewer
    and selecting 'Manipulate'.

    After the manipulation has been started, the user can drag-drop the gizmo's
    handles in the viewer to transform the objects' position in the viewer. The
    idea is: everything that happens to the gizmo happens 1:1 to the object
    being manipulated.

    Pressing Enter will submit the manipulation and pressing Esc will cancel it.
    In the first case, the :meth:`on_submit` will be called; otherwise
    :meth:`on_cancel` will. Typically, you'll want to override on_submit and
    update the manipulable object's position or reference with the position that
    the object had when the user submitted the Manipulation.

    The only required input is :attr modes: the ManipulationModes in which this
    object can be manipulated. For convenience, we expose in
    `parapy.gui.manipulation.modes` the basic modes:

    PRIMARY_AXIS_TRANSLATIONS: translate the object along X, Y and Z
    PRIMARY_AXIS_PLANAR_TRANSLATIONS: move the object freely on the X, Y and Z planes
    PRIMARY_AXIS_ROTATIONS: rotate the object around X, Y and Z

    >>> from parapy.geom import Cube, Position
    ... from parapy.gui.manipulation import ManipulableBase, EndEvent
    ... from parapy.gui.manipulation.modes import PRIMARY_AXIS_TRANSLATIONS
    ...
    ... class MyCube(Cube, ManipulableBase):
    ...     def on_submit(self, evt:EndEvent):
    ...         self.position = evt.current_position
    ...
    ... # obj can be translated along global X, Y, and Z
    ... obj = MyCube(modes=PRIMARY_AXIS_TRANSLATIONS)

    NB all orientations are to be interpreted relative to the Manipulable
    object's :attr:`position`.

    >>> # obj can be translated along obj.Vx, obj.Vy, obj.Vz
    ... obj = MyCube(position=Position().rotate(x=.1),
    ...                 modes=PRIMARY_AXIS_TRANSLATIONS)

    (If the object can be rotated, these orientations will rotate too)

    >>> obj = MyCube(1, modes=[
    ...     Translation('x'), # can be dragged along x
    ...     Translation('y'), # and along y
    ...     Rotation('z') # and rotated around z
    ...     ])

    Alternatively, modes can be *implemented* inside the class
    definition (statically like below or even wrapped inside a slot):
    >>> from parapy.geom import Cube, Position
    ... from parapy.gui.manipulation import ManipulableBase, EndEvent
    ... from parapy.gui.manipulation.modes import PRIMARY_AXIS_TRANSLATIONS
    ...
    ... class ManipulableCube(Cube, ManipulableBase):
    ...     modes = [Translation('x'),
    ...              Translation('y'),
    ...              Rotation('z')]
    ...
    ...     def on_submit(self, evt:EndEvent):
    ...         self.position = evt.current_position
    ...
    ... obj = ManipulableCube(dimension=1)

    Configuration options:
    ======================
    - By default, the gizmo's will be displayed at the same position the object
        being manipulated is. If the :attr:`position` of the object is not a
        good reference for the gizmo (e.g. it gets in the way of other shapes,
        one can specify a different position for it via
        :attr:`gizmo_position`.
    - Change the size of the Manipulator: see :attr:`gizmo_size.
    - Show a different representation of the shape that is being dragged, see
        :attr:`ghost`.
    - Choose whether guide lines should be shown when the gizmo is dragged
        see :attr:`show_guides`. Want more fine-grained control on which mode
        should show guides? Pass them via each ManipulationMode:

    >>> obj = MyCube(1, show_guides=False,
    ...     modes=[
    ...         Translation('y'), # will not show a guide by default
    ...         Translation('x', show_guide=True), # this one will
    ...     ])

    - By default, we color the gizmo handles based on their orientation:
        X becomes red, Y green and Z blue. Want to change that? pass a different
        :attr:`manipulator_xyz_component_colors`. Want even more fine-grained
        control? each ManipulationMode can have its own :attr:`handle_color`:

    >>> obj = MyCube(1, modes=[
    ...     Translation('x', handle_color=(12,150,44)),
    ...     Translation('y', handle_color='black'),
    ...     Rotation('z') # default: blue
    ...     ])
    - Using :attr:`bidirectional_gizmo_arrows` you can choose if the
        gizmo handles for the 'axis' ManipulationMode are facing both
        ways relative to their axis vector (v_<-->v+) or only one ( -->v+).
    - By setting :attr:`zoom_persistent` to True, the gizmo will not scale
        in the viewer like other objects do. Mind that in this case, the
        :attr:`gizmo_size` will mean 'pixels', and not 'world units'.

    Advanced usage/behaviour:
    =========================
    - Set limits to where the Manipulable can move, or override the behavior
        of what should happen when manipulating the object (the position
        it should be actually dragged to, displaying information about the
        manipulation or stopping some kinds of movement from happening), see
        :meth:`on_motion`.
    - Chance to setup the UI before manipulation becomes active
        :meth:`on_setup`, e.g. adjust the camera.
     - Chance to teardown the UI after manipulation ends
        :meth:`on_teardown`, e.g. reset the camera.
    - Provide your own Gizmo by overriding GIZMO_CLS; make sure to conform to
        the GizmoBase interface.
    - If you pass :attr:`rotation_persistent` to a ManipulationMode, the mode
        will keep its global orientation throughout the manipulation.

    >>> # obj can be translated along obj.Vx (even if obj.Vx
    ... #  were to change during manipulation) and Vector(0,1,0)
    ... obj = MyCube(modes=[Translation('x'),
    ...                        Translation('y',
    ...                           rotation_persistent=True)])

        By default, the mode is defined in terms of the position of the gizmo.
        That means, that even if a Mode is rotation pesistent, it remains
        relative to the object's position at the time the manipulation starts.

    >>> # obj can be translated along obj.Vx (even if obj rotates)
    ... # and GLOBAL VX (because 'y' becomes global X in YOZ)
    ... from parapy.geom import YOZ # x is z, y is x
    ... obj = MyCube(position=YOZ,
    ...                 modes=[Translation('x'),
    ...                        Translation('y',
    ...                           rotation_persistent=True)])

        For this reason it is also possible to pass a reference to each
        ManipulationMode: that is, an axis system in which the mode is defined.
        This way, it is possible to reliably transform objects along vectors
        defined in arbitrary axis systems.

    >>> # obj can be translated along obj.Vx and Vector(0,1,0)
    ... obj = MyCube(position=Position().rotate(x=.1),
    ...                 modes=[Translation('x'),
    ...                        Translation('y',
    ...                           reference=Position(),
    ...                           rotation_persistent=True)])

    """

    #: Vectors to be used for translation in `axis` mode.
    #: Any number of Vectors will work. Also 'standard' vector names such as
    # 'x',
    #: 'y_', 'z' are allowed. The vectors are considered to be relative to
    #: self.position (so if self.position is rotated, these vectors will rotate
    #: along with it).
    #: :type: typing.Sequence[str, Vector]
    translation_axes = Input(DEFAULT_AXES, preprocessor=ensure_vectors,
                             widget=MultiCheckBox(DEFAULT_AXES,
                                                  labels=list('xyz')))

    #: Vectors to be used for translation in `planar` mode.
    #: Any number of Vectors will work. Also 'standard' vector names such as
    # 'x',
    #: 'y_', 'z' are allowed. The vectors are considered to be relative to
    #: self.position (so if self.position is rotated, these vectors will rotate
    #: along with it).
    #: :type: typing.Sequence[str, Vector]
    plane_normals = Input([],
                          preprocessor=ensure_vectors,
                          widget=MultiCheckBox(DEFAULT_AXES,
                                               labels=list('xyz')))

    #: Vectors to be used for rotating in `rotation` mode.
    #: Any number of Vectors will work. Also 'standard' vector names such as
    # 'x',
    #: 'y_', 'z' are allowed. The vectors are considered to be relative to
    #: self.position (so if self.position is rotated, these vectors will rotate
    #: along with it).
    #: For control over the rotation center, you can pass Pivot objects with
    #: `fixed_center`=True and a `point` of your choosing.
    #: :type: typing.Sequence[str, Vector, Pivot]
    rotation_normals = Input([],
                            preprocessor=ensure_vectors,
                            widget=MultiCheckBox(DEFAULT_AXES,
                                                 labels=list('xyz')))

    #: discrete step size to which translation is rounded (world units)
    increment_translation: float = Input(None)
    #: discrete step size to which rotation is rounded (radians)
    increment_rotation: float = Input(None)

    @Attribute
    def modes(self):
        """Unifies the inputs into ManipulationMode instances with all
        extra information passed in the mixin's inputs
        """
        show_guides = self.show_guides
        translation_increment = self.increment_translation
        rotation_increment = self.increment_rotation

        modes = []

        for axis in self.translation_axes:
            mode = Translation(axis,
                               increment=translation_increment,
                               show_guide=show_guides)
            modes.append(mode)

        for normal in self.rotation_normals:
            mode = Rotation(normal,
                            increment=rotation_increment,
                            show_guide=show_guides)
            modes.append(mode)

        for normal in self.plane_normals:
            mode = PlanarTranslation(normal,
                                     increment=translation_increment,
                                     show_guide=show_guides)
            modes.append(mode)

        return modes


if __name__ == '__main__':
    from parapy.gui import display
    from parapy.geom import Cube
    from math import radians


    class ManipulableCube(Manipulable, Cube):
        label = "manipulable box with mixin for inputs and widgets"
        gizmo_size = .5
        increment_rotation = radians(5)
        # manipulator_xyz_component_colors = ('pink', 'purple', 'gray')
        # disable plane normals by default

        centered = True

        # comment these methods away if you don't need them. Also doing:
        # on_setup = None
        # will work.
        def on_setup(self, viewer):
            print('SETUP')

        def on_teardown(self, viewer):
            print('TEARDOWN')

        def on_motion(self, evt: MotionEvent):
            print('MOVEY MOVEY')

        def on_submit(self, evt: EndEvent):
            print('SUBMITTED')
            self.position = evt.current_position

        def on_cancel(self, evt: EndEvent):
            print('CANCELLED')


    display([
        ManipulableCube(1)
    ])
