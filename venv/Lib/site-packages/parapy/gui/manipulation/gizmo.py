#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.
import math
import typing
from warnings import warn

from parapy.core import Input, Attribute, Part, child, Base
from parapy.core.abstract import DrawableParaPyObject
from parapy.core.globs import Undefined
from parapy.core.validate import AdaptedValidator
from parapy.core.widgets import CheckBox
from parapy.geom import (
    Position, Sphere, RectangularFace, GeomBase, LineSegment, Arc2A, Circle,
    Compound, Cone)
from parapy.geom.occ.drawable import DrawableShape
from parapy.gui.manipulation.globs import XYZ_COMPONENT_COLORS
from parapy.gui.manipulation.modes import (
    ManipulationMode, PRIMARY_AXIS_TRANSFORMATIONS, Translation,
    PlanarTranslation, Rotation, FreeMove, ALL_TRANSFORMATIONS)

__all__ = "Gizmo", 'HandleBase'

A90 = math.radians(90)


class HandleBase(Base):
    """Base class for manipulation handles, to be used in a Gizmo. The purpose
    of a HandleBase is to give the Gizmo a visual shape that can be
    drag-and-dropped in the Viewer during a manipulation.
    Drag-and-dropping a HandleBase will manipulate the object using the
    ManipulationMode :attr `mode`:
    """
    size = Input(1, defaulting=True)
    mode: ManipulationMode = Input()
    reference: Position = Input()

    # doesn't mix well with SetHilightMode(AIS_Shaded)
    transparency = Attribute(0)

    # color of the boundary lines of the handle shapes.
    boundary_color: typing.Union[typing.Tuple[int,int,int], str] = 'black'

    # how close to the shape the mouse needs to be before it is detected as
    # 'under the mouse'. OCC documentation is unclear as to what the unit is
    # and what the default value is. Could be pixels, could be 1. # todo research
    selection_sensitivity:int = None

    @Attribute
    def transformed_mode(self):
        """transform the input mode` from the axis system in
        which it was defined to the axis system in which the handle is now.
        """
        return self.mode.transformed(self.reference)

    @Attribute
    def normal(self):
        raise NotImplementedError()

    xrot = Input(2)
    yrot = Input(1)
    zrot = Input(1)

    @Attribute
    def aligned_reference(self):
        axis = self.normal
        reference = self.reference
        if axis.is_almost_equal(reference.Vx):
            return reference.rotate(x=-A90, y=-A90, z=-A90)
        elif axis.is_almost_equal(reference.Vy):
            return reference.rotate(x=A90, y=2 * A90, z=A90)
        elif axis.is_almost_equal(reference.Vz):
            return reference
        else:
            return reference.align(reference.Vz, axis)


class AxisHandle(HandleBase, Compound):
    mode: Translation = Input()
    reference: Position = Input()

    n_head_wires = Input(16)
    solid_head = Input(True)

    @Input
    def head_length(self):
        return self.size * .1

    @Input
    def head_width(self):
        return self.head_length * .4

    @Attribute
    def body_length(self):
        return self.size - self.head_length

    @Attribute
    def normal(self):
        return self.transformed_mode.axis

    @Attribute
    def end_reference(self):
        return self.aligned_reference.translate(self.normal, self.body_length)

    @Attribute
    def built_from(self):
        return [self.body] + self.head

    @Attribute(in_tree=True)
    def head(self):
        if self.solid_head:
            return [self._solid_head]
        return self._wireframe_head

    @Part
    def body(self):
        return LineSegment(start=self.reference.point,
                           end=self.end_reference.point)

    @Attribute
    def _head_pos(self):
        ref = self.aligned_reference
        normal = self.normal
        trsl = ref.translate(normal, self.body_length)
        if not trsl.Vz.is_almost_equal(normal):
            if trsl.Vz.is_parallel(normal):
                trsl = trsl.rotate(x=180, deg=True)
            else:
                trsl = trsl.align(trsl.Vz, normal)
        return trsl

    @Attribute
    def _solid_head(self):
        return Cone(position=self._head_pos,
                    radius1=self.head_width / 2,
                    radius2=0,
                    height=self.head_length,
                    color=self.color)

    @Attribute
    def _wireframe_head(self):
        n_head_wires = self.n_head_wires
        normal = self.normal
        end = self.end_reference.point
        head_hsize = self.head_width / 2
        step = math.radians(360) / n_head_wires
        lines = []
        head_pos = self._head_pos
        for i in range(n_head_wires):
            head_pos = head_pos.rotate(normal, step)
            pt_ = head_pos.get_point(y=head_hsize)
            lines.append(LineSegment(start=pt_, end=end,
                                     line_thickness=self.line_thickness))
        lines.append(Circle(head_hsize,
                            position=head_pos,
                            line_thickness=self.line_thickness))
        return lines


class CenterHandle(HandleBase, Sphere):
    mode: FreeMove = Input()
    reference: Position = Input()
    mesh_deflection = Input(1e-3) # better look

    @Attribute
    def position(self):
        return self.reference

    @Attribute
    def radius(self):
        return self.size * .05


class PlanarHandle(HandleBase, RectangularFace):
    mode: PlanarTranslation = Input()
    reference: Position = Input()

    size_factor = Input(.4)

    @Input
    def width(self):
        return self.size * self.size_factor

    @Input
    def length(self):
        return self.size * self.size_factor

    @Attribute
    def normal(self):
        return self.transformed_mode.normal

    @Attribute
    def position(self):
        # we guarantee it will look good for x, y, z;
        # for the rest you're on your own
        tx = self.size * self.size_factor * .5
        return self.aligned_reference.translate(x=tx, y=tx)


class RotationHandle(HandleBase, Arc2A):
    mode: Rotation = Input()
    reference: Position = Input()

    radius = Input(defaulting='size')
    invert_position = Input(False)
    span = Input(A90)

    size = Attribute(NotImplemented)  # has no meaning
    mesh_deflection = Input(1e-5) # else looks edgy

    selection_sensitivity = 30

    @Attribute
    def angle1(self):
        return 0

    @Attribute
    def angle2(self):
        return self.span

    @Attribute
    def normal(self):
        return self.transformed_mode.normal

    @Attribute
    def position(self):
        # we guarantee it will look good for x, y, z;
        # for the rest you're on your own
        deg90 = A90
        ref = self.aligned_reference.rotate(z=(deg90 - self.span) / 2)
        if self.invert_position:
            return ref.replace(orientation=-ref.orientation)
        return ref


def _validate_modes(modes):
    assert len(modes) > 0
    for mode in modes:
        assert isinstance(mode, ManipulationMode)
    return True


def mode_preprocessor(val, slot):
    if isinstance(val, (str, ManipulationMode)):
        val = (val,)
    return ManipulationMode.convert(*val)


class GizmoBase(GeomBase):
    """Base class for *gizmo's*, a (collection of) shape that a user interacts
    with to translate and/or rotate an object.
    """
    # controls the line thickness of all 2d gizmo handles
    line_thickness = Input(2)

    # allows scaling the gizmo
    size = Input(1)

    #: If True, :attr `size`: means 'on-screen pixels', and none of
    #: the gizmo's shapes will be resized on Viewer zoom.
    #: If False, :attr `size`: 'world-units', and the gizmo will scale
    #: along with all other shapes in the viewer.
    zoom_persistent = Input(False)

    #: how to color the gizmo shapes based on their 'reference' axis components
    xyz_component_colors = Input(XYZ_COMPONENT_COLORS)

    @Attribute
    def shapes(self) -> typing.Sequence[DrawableShape]:
        # by default all tree slots are visualizable and interactive
        # when the gizmo is active during manipulation
        shapes = []
        for attr, slot in self._tree_slots.items():
            value = self.get_slot_value(attr)
            if value is Undefined:
                continue
            if hasattr(value, "__iter__"):
                shapes.extend(value)
            else:
                shapes.append(value)
        return shapes

    @Attribute
    def interactive_shapes(self) -> typing.Sequence[HandleBase]:
        """Override and pass a subset of self.shapes to be highlighted in
        the viewer when hovering with the mouse,
        to give a visual hint that these are interactive and can be dragged
        to manipulate the gizmo. Preferably, ensure that only HandleBase
        instances are returned; otherwise the shape will be highlighted on hover
        but dragging it will not trigger a transformation.
        """
        handle_selector = filter(lambda x: isinstance(x, HandleBase),
                                 self.shapes)
        return tuple(handle_selector)  # noqa

    def interactive_shape_to_manipulation_mode(
            self,
            detected_object: DrawableParaPyObject) -> \
            typing.Optional[ManipulationMode]:
        """maps interactive shapes to manipulation modes; by default,
        it exploits the assumption that interactive_shapes are GizmoHandles,
        which hold their own :attr `mode`:.
        """
        raise NotImplementedError()


class Gizmo(GizmoBase):
    """Representation of a 'Manipulator' object. Its :attr `shapes`: are
    displayed when a manipulation starts, and its :attr `interactive_shapes`:
    are used to drag the gizmo. Each interactive_shape
    """

    #: the manipulation modes that this manipulable supports. Any combination
    #: of ManipulationMode instances will work (but handles may overlap)
    modes = Input(PRIMARY_AXIS_TRANSFORMATIONS,
                  validator=AdaptedValidator(
                      _validate_modes,
                      msg="Modes needs to be a nonempty sequence "
                          "of ManipulationMode instances."))

    #: whether to show the rotation handles on the opposite side of the gizmo
    #: :type: numbers.Number
    rotation_handles_invert_position = Input(False, widget=CheckBox)

    #: length of the rotation handles
    #: :type: numbers.Number
    rotation_handles_radians = Input(A90)

    #: toggles whether translation arrows for the 'Translation' mode should be
    #: drawn as solid cones or as hollow wires.
    #: typing.Optional[bool]
    solid_arrow_heads = Input(True, widget=CheckBox)

    #: If set to :py:`True` the size of the gizmo will be defined in
    #: on-screen pixels and will not resize when zooming. Otherwise the
    #: gizmo's size will be defined in world-units, and will be
    #: zoomed in or out like a regular shape.
    zoom_persistent = Input(False, widget=CheckBox)

    #: if the gizmo has a center shape: what colour it should be. The center
    # is only visible if no other manipulation
    # mode than Axis is available
    center_color = Input('white')

    #: how to color the gizmo shapes based on their 'reference' axis components
    xyz_component_colors = Input(XYZ_COMPONENT_COLORS)

    # lock certain viewer-related properties
    display_mode = Attribute("shaded")
    transparency = Attribute(0.0)

    @Input
    def size(self) -> typing.Union[int, float]:
        """If :attr:`zoom_persistent` is :py:`True`,
        this will be the size of the main axes of the gizmo in on-screen
        pixels. If :attr:`zoom_persistent` is :py:`False`, it is the size
        of the main axes in world-units.

        :rtype: int
        """
        if self.zoom_persistent:
            return 60  # bit of a random guess, seems reasonable in most cases
        return 1

    def _to_color(self, mode: ManipulationMode):
        return mode.get_handle_color(self.xyz_component_colors)

    def _get_modes_of_type(self, mode_cls):
        return tuple(
            filter(lambda mode: isinstance(mode, mode_cls), self.modes))

    @Attribute
    def _axis_modes(self):
        return self._get_modes_of_type(Translation)

    @Attribute
    def _plane_modes(self):
        return self._get_modes_of_type(PlanarTranslation)

    @Attribute
    def _rotation_modes(self):
        return self._get_modes_of_type(Rotation)

    @Attribute
    def _free_move_mode(self):
        # no subclasses
        modes = [mode for mode in self.modes if type(mode) is FreeMove]
        if len(modes) > 1:
            warn("Gizmo only supports one FreeMove at a time")
        if not modes:
            return
        return modes[0]

    @Part
    def arrows(self):
        return AxisHandle(
            quantify=len(self._axis_modes),
            mode=self._axis_modes[child.index],
            solid_head=self.solid_arrow_heads,
            reference=self.position,
            color=self._to_color(child.mode),
            head_length=self.size / 3)

    @Part
    def _planar_handles(self):
        return PlanarHandle(
            quantify=len(self._plane_modes),
            mode=self._plane_modes[child.index],
            reference=self.position,
            color=self._to_color(child.mode)
        )

    @Part
    def _center_handle(self):
        return CenterHandle(
            reference=self.position,
            mode=self._free_move_mode,
            size=self.size,
            color=self._to_color(self._free_move_mode),
            suppress=not self._free_move_mode
        )

    @Part
    def rotation_handles(self):
        return RotationHandle(
            quantify=len(self._rotation_modes),
            mode=self._rotation_modes[child.index],
            reference=self.position,
            color=self._to_color(child.mode),
            invert_position=self.rotation_handles_invert_position,
            span=self.rotation_handles_radians
        )

    def interactive_shape_to_manipulation_mode(
            self,
            detected_object: DrawableParaPyObject) -> \
            typing.Optional[ManipulationMode]:
        """Given a drawable object, returns the ManipulationMode
        it corresponds to, if any.
        """

        if isinstance(detected_object, HandleBase):
            return detected_object.transformed_mode
        return None


if __name__ == '__main__':
    from parapy.gui import display, set_position_rendering
    from parapy.gui.manipulation.modes import (
        Rotation, PlanarTranslation, FREEMOVE)
    from parapy.geom import Vector

    gizmos = [
        Gizmo(modes=ALL_TRANSFORMATIONS,
              position=Position(),
              label='vanilla gizmo'),
        Gizmo(modes=ALL_TRANSFORMATIONS,
              position=Position().translate(x=4),
              rotation_handles_invert_position=True,
              label='inverted rotation handles'),
        Gizmo(modes=ALL_TRANSFORMATIONS,
              position=Position().translate(x=8).rotate(x=45, deg=True),
              rotation_handles_radians=math.radians(270),
              rotation_handles_invert_position=True,
              label='longer rotation handles'),
        Gizmo(modes=[
            Rotation(Vector(1, 1, 1).normalize),
            Rotation(Vector(1, 2, 3).normalize),
            Rotation(Vector(6, 6, 3).normalize),
            FREEMOVE],
            position=Position().translate(x=12).rotate(y=45, deg=True),
            label='custom modes'),
        Gizmo(modes=[Rotation(Vector(1, 0, 0))],
              position=Position().translate(x=16),
              label='test'
              ),
    ]

    set_position_rendering('axes', size=.5)
    display(gizmos)
