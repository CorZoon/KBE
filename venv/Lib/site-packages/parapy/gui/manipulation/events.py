#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from typing import TYPE_CHECKING, Tuple

from parapy.core.events import VetoableEvent

if TYPE_CHECKING:
    from parapy.geom import Position
    from parapy.gui.manipulation import ManipulationMode
    from parapy.geom.generic.transformation import Transformation
    from parapy.gui.viewer import Viewer

MousePosition = Tuple[int, int]


class ManipulationEvent(VetoableEvent):
    def Skip(self, skipped=True):
        raise RuntimeError("Skipping not supported on ManipulationEvent")


class MotionEvent(ManipulationEvent):
    """Event fired on motion.
    `mouse_position`: the position of the mouse at the time this event was fired
    `start_position`: the reference position of the object being manipulated
    `current_position`: the current position of the object
    `previous_position`: the previous position, corresponding to the previous
        event's current_position. This allows the user to easily `undo` a
        MotionEvent by rolling back the last change:
        >>> def on_motion(self, evt:MotionEvent):
        ...     evt.current_position = evt.previous_position
        Note: if this event is the first one, the previous_position will be
        equal to start_position.
    `transformation`: a Transformation object that encapsulates the transformation
      from start_position to current_position. Ideal if you want to apply the same
      transformation to multiple objects.
     especially useful if RotationManipulationMode is active. Equivalent to
     translating by the vector (evt.current_position-evt.start_position) and then
     applying a rotation matrix corresponding to the rotations that start_position
     has undergone.

    `mode`: the manipulation mode currently active.
    `source`: the source of this event; the Viewer in which the
        manipulation is active
    """
    mouse_position: MousePosition
    start_position: 'Position'
    current_position: 'Position'
    transformation: 'Transformation'
    previous_position: 'Position'
    mode: 'ManipulationMode'
    source: 'Viewer'


class EndEvent(ManipulationEvent):
    """Event fired on motion.
    `mouse_position`: the position of the mouse at the time this event was fired
    `start_position`: the reference position of the object being manipulated
    `current_position`: the current position of the object
    `transformation`: a Transformation object that encapsulates the transformation
      from start_position to current_position. usage:
    >>> def on_end(self, evt: EndEvent, obj):
    ...     if evt.submitted:
    ...         self.position = evt.transformation.apply(self.position)
     especially useful if RotationManipulationMode is active. Ideal if you want
     to apply the same transformation to multiple objects. Equivalent to first
     translating by the vector (evt.current_position-evt.start_position) and then
     applying a rotation matrix corresponding to the rotations that start_position
     has undergone.
    `source`: the source of this event; the Viewer in which the
        manipulation is active
    `submitted`: whether the manipulation has been accepted (True) or
        cancelled (False).
    """
    start_position: 'Position'
    current_position: 'Position'
    transformation: 'Transformation'
    source: 'Viewer'
    submitted: bool  # None if not submit event (viz. motion)


def create_motion_event(mouse_position: MousePosition,
                        start_position: 'Position',
                        previous_position: 'Position',
                        current_position: 'Position',
                        transformation: 'Transformation',
                        mode: 'ManipulationMode',
                        source: 'Viewer'):
    return ManipulationEvent(mouse_position=mouse_position,
                             start_position=start_position,
                             previous_position=previous_position,
                             current_position=current_position,
                             transformation=transformation,
                             mode=mode,
                             source=source)


def create_end_event(start_position: 'Position',
                     current_position: 'Position',
                     transformation: 'Transformation',
                     source: 'Viewer',
                     submitted: bool):
    return EndEvent(start_position=start_position,
                    current_position=current_position,
                    transformation=transformation,
                    source=source,
                    submitted=submitted)
