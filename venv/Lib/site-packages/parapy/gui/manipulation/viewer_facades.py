#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.
from functools import partial

from OCC.wrapper.Graphic3d import (
    Graphic3d_ZLayerId_Top, Graphic3d_TransformPers, Graphic3d_TMF_ZoomPers)
from OCC.wrapper._AIS import AIS_Shaded
from OCC.wrapper.gp import gp_Pnt

from parapy.core import apply_to_all
from parapy.geom import XOY, Position
from parapy.geom.occ.transform import get_transformation, rebase_trsf
from parapy.gui.manipulation.gizmo import Gizmo, HandleBase
from parapy.gui.manipulation.utils import pp_to_quantity


class ViewerFacade(object):
    """Facade to :meth:`display` multiple ``shapes`` in ``viewer``
    :meth:`transform` them efficiently, and :meth:`remove` them from viewer at
    the end, optionally resetting shapes back to original location/orientation.

    >>> shapes = [box1, box2]
    >>> facade = ViewerFacade(shapes, viewer)
    >>> facade.display()
    >>> facade.transform(old_position, new_position)
    >>> facade.remove()
    """

    def __init__(self, shapes, viewer):
        self._shapes = shapes
        self._viewer = viewer
        self._ais_shapes_to_pp: dict = {}  # is set via .display()

    def display(self, update=True, **kwargs):
        raise NotImplementedError()

    def transform(self, from_position, to_position, update=True):
        """Transform all shapes in viewer."""
        trsf = get_transformation(from_position, to_position)

        for ais_shape, pp_obj in self._ais_shapes_to_pp.items():
            self._transform_shape(
                ais_shape, from_position, to_position, trsf)

        if update:
            self._update_viewer()

    def remove(self, reset_transformation=True, update=True, **kwargs):
        """Removes ``shapes`` from ``viewer``

        :param bool reset_transformation: reset original shapes?
        :param bool update: update viewer?
        :param dict kwargs: see :meth:`~parapy.gui.viewer.Viewer.remove`.
        """
        if reset_transformation:
            self._reset_transformation()

        self._viewer.remove(self._shapes, update=update, **kwargs)

    @staticmethod
    def _transform_shape(ais_shape, from_position, to_position,
                         local_trsf=None):
        if not local_trsf:
            trsf = get_transformation(from_position, to_position)
            local_trsf = rebase_trsf(trsf, from_position, XOY)

        ais_shape.SetLocalTransformation(local_trsf)

    def _reset_transformation(self):
        for ais_shape in self._ais_shapes_to_pp:
            ais_shape.ResetTransformation()

    def _update_viewer(self):
        self._viewer.update()


class GizmoViewerFacade(ViewerFacade):
    """A facade to make it easier to manage the shape of the gizmo
    (Manipulator) in the Viewer during a Manipulation by providing
    display/transform/remove methods.
    """

    def __init__(self, gizmo: Gizmo, viewer):
        shapes = gizmo.shapes
        # the arrows should appear with a shaded highlight to show
        # that the user should interact with it
        self._shaded_highlight_shapes = gizmo.interactive_shapes

        super(GizmoViewerFacade, self).__init__(shapes, viewer)
        self._ais_shapes = []
        self._shaded_highlight_ais = []

        self._gizmo = gizmo
        self._zoom_persistent = gizmo.zoom_persistent

    def shape_to_ais(self, shape):
        try:
            ais = shape._Handle_AIS_InteractiveObject
        except Exception as e:
            raise RuntimeError(f'AIS shape evaluation failed on {shape};'
                               f'impossible to display gizmo') from e
        return ais

    def display(self, update=True, **kwargs):
        """Display, but also apply style to shapes on AIS level.
        """
        shapes = self._shapes
        self._ais_shapes = ais_shapes = tuple(map(self.shape_to_ais, shapes))

        viewer = self._viewer
        occ_viewer = viewer._occ_viewer
        display = partial(occ_viewer.display, update=False, fit=False)

        # todo: we are using the viewer still for left-click recognition of the
        #  clicked shapes, but it would be neater if we would bypass that too
        #  and only talk to the OCC viewer, but this requires quite a rework
        #  of Manipulation's event handling.
        # need to inform the viewer about these 'internally managed' shapes,
        # else gui events won't be propagated to Manipulation because the Viewer
        # has no knowledge of their existence:
        pp_to_ais = viewer._dct_pp_occ
        ais_to_pp = viewer._dct_occ_pp

        self._ais_shapes_to_pp = _ais_to_pp = dict(zip(ais_shapes, shapes))

        for ais, pp in _ais_to_pp.items():
            display(ais)
            ais_to_pp[ais] = pp
            pp_to_ais[pp] = ais

            viewer.activate_selection_mode(obj=pp, mode='default')

        self._shaded_highlight_ais = frozenset([
            pp_to_ais[shape] for shape in self._shaded_highlight_shapes])
        apply_to_all(self._style_shape, ais_shapes)

        if update:
            self._update_viewer()

    def remove(self, reset_transformation=True, update=True, **kwargs):
        if reset_transformation:
            self._reset_transformation()

        viewer = self._viewer
        remove = partial(viewer._occ_viewer.remove, update=False, fit=False)
        ais_to_pp = viewer._dct_pp_occ
        pp_to_ais = viewer._dct_occ_pp

        for ais, shape in zip(self._ais_shapes, self._shapes):
            remove(ais)
            # someone may have removed these in the meantime
            if ais in ais_to_pp:
                del ais_to_pp[ais]
            if shape in pp_to_ais:
                del pp_to_ais[shape]

        if update:
            self._update_viewer()

    def _transform_shape(self, ais_shape, from_position: Position,
                         to_position: Position,
                         local_trsf=None):

        handle: HandleBase = self._ais_shapes_to_pp[ais_shape]
        if isinstance(handle, HandleBase):
            if not handle.mode.relative:
                # if the mode is absolute, then we need a local trsf
                # to set rotation persistence
                to_position = to_position.replace(
                    orientation=from_position.orientation)
                local_trsf = get_transformation(from_position, to_position)

        return super()._transform_shape(ais_shape, from_position, to_position,
                                        local_trsf=local_trsf)

    def _style_shape(self, ais_shape):
        """Forces shapes to (highlight) in shaded mode"""
        # show on top of other things drawn in the viewer
        occ_viewer = self._viewer._occ_viewer
        ais_context = occ_viewer._ais_context

        ais_to_pp = self._ais_shapes_to_pp
        pp_shape: HandleBase = ais_to_pp[ais_shape]
        style = pp_shape._display_style()
        occ_viewer.apply_style(ais_shape, update=False, **style)

        ais_shape.SetZLayer(Graphic3d_ZLayerId_Top)

        boundary_color = pp_shape.boundary_color
        if boundary_color:
            line_aspect = ais_shape.Attributes().LineAspect()
            line_aspect.SetColor(pp_to_quantity(pp_shape.boundary_color))
            line_aspect.SetWidth(pp_shape.line_thickness)

        if ais_shape in self._shaded_highlight_ais:
            ais_shape.SetHilightMode(AIS_Shaded)

        selection_sensitivity = pp_shape.selection_sensitivity
        if selection_sensitivity is not None:
            selection_mode = 0 # stands for 'whole object'
            ais_context.SetSelectionSensitivity(ais_shape, selection_mode,
                                                selection_sensitivity)

        if self._zoom_persistent:
            transform_pers = Graphic3d_TransformPers(
                Graphic3d_TMF_ZoomPers).handle

            gizmo_location = self._gizmo.position.location
            transform_pers.SetAnchorPoint(gp_Pnt(*gizmo_location))
            ais_shape.SetTransformPersistence(transform_pers)


class GhostViewerFacade(ViewerFacade):
    """A facade to make it easier to manage the shape of the ghost in the
    Viewer during a Manipulation by providing display/transform/remove methods.
    """

    def __init__(self, ghost, viewer):
        super(GhostViewerFacade, self).__init__([ghost], viewer)
        self._ghost = ghost
        self._was_already_in_viewer = None  # is set in .display()

    def display(self, update=True, **kwargs):
        """Display all ``shapes`` in ``viewer``.

        :param bool update: update viewer?
        :param dict kwargs: see
        :meth:`~parapy.gui.viewer.Viewer.display`.
        """

        viewer = self._viewer
        # this state is used on remove()
        self._was_already_in_viewer = self._ghost in viewer._dct_pp_occ

        shapes = self._shapes
        viewer.display(shapes, update=update, **kwargs)

        shape_to_ais = viewer._dct_pp_occ
        ais_to_pp = {shape_to_ais[s]: s for s in shapes}
        self._ais_shapes_to_pp = ais_to_pp

        for shape in shapes: # make shapes undetectable=unselectable
            viewer.deactivate_selection_mode(obj=shape, mode='default')

    def remove(self, reset_transformation=True, update=True, **kwargs):
        # only remove ghost, if not already shown in Viewer before (not ours)
        if not self._was_already_in_viewer:
            super(GhostViewerFacade, self).remove(
                reset_transformation=reset_transformation, update=update,
                **kwargs)
        elif reset_transformation:
            self._reset_transformation()

        self._was_already_in_viewer = None



if __name__ == '__main__':
    from parapy.gui.display import display
    from parapy.geom import Cube
    from parapy.gui.manipulation import Manipulable
    from parapy.gui.manipulation.modes import ALL_TRANSFORMATIONS

    class MyObj(Cube, Manipulable):
        modes = [m.copy(show_guide=True) for m in ALL_TRANSFORMATIONS]

    display(MyObj(1))