#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.
import typing
from numbers import Number
from typing import TYPE_CHECKING
from warnings import warn

from OCC.gui.interactive_objects import make_ais_line, make_ais_coloredshape

from parapy.geom import (
    Point, RectangularFace, Position, Circle, Vector)
from parapy.geom.generic.transformation import rebase_vector
from parapy.gui.manipulation.globs import DEFAULT_AXES_TO_COLORS
from parapy.gui.manipulation.structs import StateTransitionSpec
from parapy.gui.manipulation.utils import (
    ais_set_style, make_ais_point, round_to_increment,
    round_vector, vector_to_color)

if TYPE_CHECKING:
    from parapy.gui.viewer import Viewer
    from OCC.wrapper.AIS import Handle_AIS_Shape  # noqa

__all__ = ("ManipulationMode", "PRIMARY_AXIS_TRANSLATIONS",
           "PRIMARY_AXIS_PLANAR_TRANSLATIONS",
           "PRIMARY_AXIS_ROTATIONS", "PRIMARY_AXIS_TRANSFORMATIONS",
           "Translation", "Rotation",
           "PlanarTranslation")

UpdateAISShapeReturnType = typing.Optional[
    typing.Sequence[
        typing.Tuple[
            'Handle_AIS_Shape', 'Handle_AIS_Shape']]]

# singleton to allow passing None to optional kwargs, where None has a meaning
UNSET = object()


class _NO_GUIDE_UPDATES:
    pass


ColorType = typing.Union[typing.Tuple[int, int, int], str]


class ManipulationMode:
    """Abstract class;
    implement at least: `transform`, `project`, `__copy_attrs__`.

    A ManipulationMode bundles instructions as to how to transform a Position
    in space, and some configuration options on how to present this possibility
    to the user.

    Transformation Instructions:
    ============================
    A mode's `project` method implements how to transform an on-screen position
        to a 3d-world position in model space, given a viewer and a
        position (to determine the 'depth').
    A mode's `transform` method implements how, given two positions in space
        (corresponding to two consecutive points in space during a drag-drop
        operation), what the 'next' position should be.

    Together, 'transform' and 'project' constitute the StateTransitionSpec; it
    is all that the TransformationState (used by Manipulation) needs to know
    to be able to keep track of where the manipulator is while the user
    drags/drops its handles and transforms it in multiple modes.

    Configuration options:
    ======================
    -  :param: `show_guide`: whether while manipulating in this mode, a guide
        should be shown to help the user orient herself.
    -  :param: `increment`: whether the transformation should be rounded at an
        increment or be as continuous as pixels and gui events allow.
    -  :param: `reference`: the axis system relative to which this
        mode is defined. All Vectors, Positions, Orientations that a Mode can
        be configured with (depending on the subclass. This abstract class does
        nothing with it), are interpreted in terms of this reference. By
        default, the reference is the gizmo's position.
    -  :param: `relative`: whether the mode should keep its
        reference as-is during a manipulation, or whether the reference should
        be allowed to rotate.
    -  :param: `handle_color`: the color of the gizmo handle representing this
        mode during manipulation.

    Advanced configuration:
    =======================
    Each built-in ManipulationMode has a default implementation of
    :meth `_create_guides`:. By overriding it is possible to change the guide
      displayed during manipulation.

    :meth: `_update_guides`: The default implementation does nothing, but it
      is possible to override this method to dynamically update or even replace
      the ais guides during manipulation. It receives whatever AIS shapes were
      returned by _create_guides, and it is expected to return a sequence of
      (old_shape, new_shape).
      For example, to highlight a line when the object being manipulated is
      aligned with it, or make a circle larger the more the object moves away
      from the initial position.

      >>> from parapy.gui.manipulation import Translation
      ... from parapy.geom import LineSegment, Circle, Position
      ... from parapy.gui.manipulation.utils import ais_set_style
      ... from OCC.gui.interactive_objects import make_ais_coloredshape
      ...
      ... class MyAxisMode(Translation):
      ...     def _create_guides(self, start_position, current_position,
      ...                          scale):
      ...         # replace the default black line with a green segment
      ...         segment = LineSegment(start_position, current_position,
      ...                               color=(0,150,0), transparency=.8)
      ...         ais = make_ais_coloredshape(segment.TopoDS_Shape)
      ...         return [ais], # return a sequence
      ...
      ...     def _update_guides(self, ais_shapes,
      ...                  initial_pos: Position,
      ...                  previous_pos: Position,
      ...                  current_pos: Position):
      ...         ais = ais_shapes[0] # the colored ais LineSegment
      ...         # make it red and solid if we moved further
      ...         # than 10 world units; else green and semitransparent
      ...         if (current_pos - initial_pos).length > 10:
      ...             color, transparency = (150,0,0), 0
      ...         else:
      ...             color, transparency = (0,150,0), .8
      ...
      ...         # if we wanted to modify the existing ais shape in-place and
      ...         # leave it at that, we could do:
      ...         #  ais_set_style(ais, color, transparency)
      ...         # and return None.
      ...         # But if we want to replace the shape with a new one:
      ...         circle = Circle(position=current_pos, radius=1, color='red')
      ...         new_ais = make_ais_coloredshape(circle.TopoDS_Shape)
      ...         return (ais, new_ais)
      ...


    """
    __slots__ = ("_show_guide", "_increment", "_reference", "_relative",
                 "_handle_color")

    # we use  __copy_attrs__ to determine how to .copy() subclasses
    __copy_attrs__ = ()

    def __init__(self,
                 show_guide: bool = False,
                 increment: typing.Optional[Number] = None,
                 reference: typing.Optional[Position] = None,
                 relative: bool = True,
                 handle_color: bool = None):
        """
        :param show_guide: whether a guide should be shown while this mode is
            active
        :param increment: increment to round manipulation by
        :param reference: the basis axis system relative to which this mode is
            defined.
            >>> # translation along global VX
            ... mode = Translation('x')

            >>> # translation along global VY
            ... mode2 = Translation('x',
            ...     reference=Position().rotate(z=90, deg=True))
            you don't _have_ to provide this argument unless you know what
            you're doing. By default, the reference will be set to the reference
            position of the object being manipulated (dynamically).
        :param relative: whether this mode's reference should be
            rotated when the object/gizmo is, or not. If True, :param reference:
            is at all effects treated as fixed (w.r.t. orientation). Otherwise
            it will rotate along with the object/gizmo.

            >>> from parapy.geom import Box
            ... pos = Position().rotate(z=90, deg=True)
            ... box = Box(1,1,1, position=pos)
            ... # translating box using this mode will translate it along
            ... # _whatever box.position.Vx is at that moment, so in fact VY
            ... rel_mode = Translation('x', relative=False)
            ... # translating box using this mode will _always_ translate it
            ... # along (global) VX.
            ... abs_mode = Translation('x', relative=True)

        :param handle_color: The color that the gizmo handle corresponding to
            this mode should have during manipulation
        """
        self._show_guide = show_guide
        self._handle_color = handle_color
        self._reference = reference or Position()
        self._relative = relative
        self._increment = increment

    @property
    def show_guide(self):
        return self._show_guide

    @property
    def handle_color(self):
        return self._handle_color

    @property
    def reference(self):
        return self._reference

    @property
    def relative(self):
        return self._relative

    @property
    def increment(self):
        return self._increment

    def transformed(self, to_position: Position):
        raise NotImplementedError()

    def _get_handle_color(self, xyz_component_colors):
        raise NotImplementedError()

    def get_handle_color(self, xyz_component_colors):
        own_color = self.handle_color
        if own_color:
            return own_color
        return self._get_handle_color(xyz_component_colors)

    def _get_copy_kwargs(self, kwargs):
        attrs = {}
        for attr in self.__copy_attrs__:
            attrs[attr] = getattr(self, attr)

        attrs.update(kwargs)

        def add_if_not_unset(key):
            val = kwargs.get(key, UNSET)
            if val is UNSET:
                val = getattr(self, key)
            attrs[key] = val

        for attr in ['show_guide', 'reference', 'relative',
                     'increment', 'handle_color']:
            add_if_not_unset(attr)

        return attrs

    def copy(self, **kwargs):
        """
        To modify on the fly ManipulationMode instances, like so:
        >>> from parapy.geom import Box, Vector
        ... from parapy.gui.manipulation import (
        ...     Manipulable, Translation, EndEvent)
        ... basis_mode = Translation(axis=Vector(1,0,0),
        ...     show_guide=False, name='my axis mode')
        ...
        ... class ManipulableBox(Manipulable, Box):
        ...     modes = [basis_mode.copy(increment=2, axis=Vector(0,1,0)),
        ...             basis_mode.copy(axis=Vector(0,0,1))]
        ...
        ...     def on_end(self, evt: EndEvent):
        ...         if evt.submitted:
        ...             self.position += evt.current_position - \
        ...                 evt.start_position
        """
        attrs = self._get_copy_kwargs(kwargs)
        return type(self)(**attrs)

    def transform(self, start_position: Position,
                  previous_location: Point,
                  current_location: Point) -> Position:
        raise NotImplementedError()

    def project(self, viewer: 'Viewer', x: int, y: int,
                position: Position) -> Point:
        raise NotImplementedError()

    @property
    def _state_transition_def(self) -> StateTransitionSpec:
        """Definition of the state transition for this manipulation mode,
        encapsulating a projector to turn on-screen clicks into
        world-coordinates and a transformer to determine how to manipulate an
        object given a start and end position (determined by an on-screen
        drag-and-drop action)
        """
        this_cls = type(self)
        abstract_cls = ManipulationMode
        if this_cls.project is abstract_cls.project or \
                this_cls.transform is abstract_cls.transform:
            raise NotImplementedError(
                "either override `project` and `transform` in your "
                "ManipulationMode subclass, or override _state_transition_def")

        return StateTransitionSpec(self.project,
                                   self.transform)

    @property
    def state_transition_def(self):
        """Definition of the state transition for this manipulation mode,
        encapsulating a projector to turn on-screen clicks into
        world-coordinates and a transformer to determine how to manipulate an
        object given a start and end position (determined by an on-screen
        drag-and-drop action)
        """
        return self._state_transition_def

    def _create_guides(self, start_pos, previous_pos, current_pos,
                         scale) -> typing.Sequence['Handle_AIS_Shape']:
        raise NotImplementedError()

    def create_guides(self, start_pos, previous_pos, current_pos, scale
                        ) -> typing.Sequence['Handle_AIS_Shape']:
        """return a sequence of AIS_Shapes that will be displayed when
        this mode is active.
        start_position is the gizmo's position when manipulation started;
        current_position is the gizmo's position at the start of the current
        drag-drop operation
        """
        if type(self)._create_guides is ManipulationMode._create_guides:
            return ()
        return self._create_guides(start_pos, previous_pos, current_pos, scale)

    def _update_guides(self, ais_shapes,
                           initial_pos: Position,
                           previous_pos: Position,
                           current_pos: Position) -> UpdateAISShapeReturnType:
        raise NotImplementedError()

    def update_guides(self, ais_shapes, initial_pos: Position,
                          previous_pos: Position, current_pos: Position
                          ) -> typing.Union[UpdateAISShapeReturnType,
                                            _NO_GUIDE_UPDATES]:
        """Update the ais_shapes in place, or return a mapping to new ais_shapes
        to replace the old ones.
       """
        if type(self)._update_guides is ManipulationMode._update_guides:
            return ()
        return self._update_guides(ais_shapes, initial_pos,
                                   previous_pos, current_pos)


class Translation(ManipulationMode):
    """ManipulationMode allowing the user to translate an object along the
    vector :param `axis`:.

    Configuration options:
    ======================
    -  :param: `show_guide`: whether while manipulating in this mode, a guide
        should be shown to help the user orient herself.
    -  :param: `increment`: whether the transformation should be rounded at an
        increment or be as continuous as pixels and gui events allow.
    -  :param: `reference`: the axis system relative to which this
        mode is defined. This mode's :param `axis`: is interpreted in terms
        of this reference. By default, the reference is the gizmo's position.
    -  :param: `relative`: whether the mode should keep its
        reference as-is during a manipulation, or whether the reference should
        be allowed to rotate.
    -  :param: `handle_color`: the color of the gizmo handle representing this
        mode during manipulation.

    Advanced configuration:
    =======================
    :meth `_create_guides`:. By default this method returns a yellow line,
      aligned with the Mode's axis and passing through the current position of
      the object being manipulated. Override it to change this behaviour.
    :meth: `_update_guides`: The default implementation does nothing.
    """
    __slots__ = ('_axis',)
    __copy_attrs__ = ('axis',)

    def __init__(self, axis: typing.Union[Vector, str],
                 show_guide: bool = False,
                 handle_color: typing.Optional[ColorType] = None,
                 increment: typing.Optional[Number] = None,
                 reference: typing.Optional[Position] = None,
                 relative: bool = True):
        super().__init__(show_guide=show_guide,
                         handle_color=handle_color,
                         increment=increment,
                         relative=relative,
                         reference=reference)
        self._axis = Vector.ensure_vector(axis)

    @property
    def axis(self):
        return self._axis

    def _get_handle_color(self, xyz_component_colors):
        return vector_to_color(self.axis, xyz_component_colors)

    def transformed(self, to_position: Position):
        from_position = self.reference
        if self.relative:
            return self.copy(
                reference=to_position,
                axis=rebase_vector(self.axis, from_position, to_position))
        return self.copy()

    def transform(self, start_position, previous_location,
                  current_location) -> Position:
        vector = previous_location.vector_to(current_location)
        increment = self.increment
        if increment:
            vector = round_vector(vector, increment)
        return start_position + vector

    def project(self, viewer, x, y, position) -> Point:
        return viewer.screen_to_point_on_axis(
            x, y, position.location, self.axis)

    def _create_guides(self, start_pos, previous_pos, current_pos, scale
                         ) -> typing.Sequence['Handle_AIS_Shape']:
        ais_line = make_ais_line(current_pos, self.axis)
        # fixme: need to do this else updating its color later
        #   (in a user-defined _update_guides method, for example) will
        #   not have any effect (color will be stuck to default yellow).
        ais_set_style(ais_line, 'black')
        return ais_line,


class FreeMove(ManipulationMode):
    """ManipulationMode allowing the user to freely translate an object in the
    viewer, on the current camera-relative plane.

    Configuration options:
    ======================
    -  :param: `show_guide`: whether while manipulating in this mode, a guide
        should be shown to help the user orient herself.
    -  :param: `increment`: whether the transformation should be rounded at an
        increment or be as continuous as pixels and gui events allow.
    -  :param: `reference`: the axis system relative to which this
        mode is defined. This mode's :param `normal`: is interpreted in terms of
        this reference. By default, the reference is the gizmo's position.
    -  :param: `relative`: whether the mode should keep its
        reference as-is during a manipulation, or whether the reference should
        be allowed to rotate.
    -  :param: `handle_color`: the color of the gizmo handle representing this
        mode during manipulation.

    Advanced configuration:
    =======================
    :meth `_create_guides`:. By default this method returns a rectangle
      representing the plane with normal :param `normal`: centered at the
      current position of the object being manipulated. Override it to change
      this behaviour.
    :meth: `_update_guides`: The default implementation does nothing.
    """

    def __init__(self, show_guide: bool = False,
                 increment: typing.Optional[Number] = None,
                 reference: typing.Optional[Position] = None,
                 relative: bool = True, handle_color: bool = None):
        super().__init__(show_guide, increment, reference, relative,
                         handle_color)
        if show_guide:
            warn('No guide is available for FreeMode (yet!).')

    def transformed(self, to_position: Position):
        return self

    def _get_handle_color(self, xyz_component_colors):
        return (255, 255, 255)  # white

    def project(self, viewer, x, y, position) -> Point:
        cam_ori = viewer.get_camera().orientation
        return viewer.screen_to_point_in_plane(
            x, y, position.location, cam_ori.z)

    def transform(self, start_position, previous_location, current_location):
        vector = previous_location.vector_to(current_location)
        # todo: does rounding really make sense in planar context?
        #  distance from center: is this expected/desired? make radial=True kwarg
        increment = self.increment
        if increment:
            vector = round_vector(vector, increment)
        return start_position + vector

    # # todo: to show a guide we need the viewer's camera; pass viewer down?
    # def _create_guides(self, start_pos, previous_pos, current_pos, scale
    #                      ) -> typing.Sequence['Handle_AIS_Shape']:
    #     v_dim = scale * 10
    #     rect = RectangularFace(position=current_pos, color="blue",
    #                            length=v_dim, width=v_dim)
    #     ais_rect = make_ais_coloredshape(rect.TopoDS_Shape)
    #     ais_set_style(ais_rect, 'green', .95)
    #     return ais_rect,


class PlanarTranslation(FreeMove):
    """ManipulationMode allowing the user to freely translate an object on
     the plane with normal :param `normal`:.

    Configuration options:
    ======================
    -  :param: `show_guide`: whether while manipulating in this mode, a guide
        should be shown to help the user orient herself.
    -  :param: `increment`: whether the transformation should be rounded at an
        increment or be as continuous as pixels and gui events allow.
    -  :param: `reference`: the axis system relative to which this
        mode is defined. This mode's :param `normal`: is interpreted in terms of
        this reference. By default, the reference is the gizmo's position.
    -  :param: `relative`: whether the mode should keep its
        reference as-is during a manipulation, or whether the reference should
        be allowed to rotate.
    -  :param: `handle_color`: the color of the gizmo handle representing this
        mode during manipulation.

    Advanced configuration:
    =======================
    :meth `_create_guides`:. By default this method returns a rectangle
      representing the plane with normal :param `normal`: centered at the
      current position of the object being manipulated. Override it to change
      this behaviour.
    :meth: `_update_guides`: The default implementation does nothing.
    """
    __copy_attrs__ = ('normal',)
    __slots__ = ('_normal',)

    def __init__(self, normal: typing.Union[Vector, str],
                 show_guide: bool = False,
                 handle_color: typing.Optional[ColorType] = None,
                 increment: typing.Optional[Number] = None,
                 reference: typing.Optional[Position] = None,
                 relative: bool = True):
        super().__init__(show_guide=show_guide,
                         handle_color=handle_color,
                         increment=increment,
                         relative=relative,
                         reference=reference)
        self._normal = Vector.ensure_vector(normal)

    @property
    def normal(self):
        return self._normal

    def _get_handle_color(self, xyz_component_colors):
        return vector_to_color(self.normal, xyz_component_colors)

    def transformed(self, to_position: Position):
        from_position = self.reference
        if self.relative:
            return self.copy(
                reference=to_position,
                normal=rebase_vector(self.normal, from_position, to_position))
        return self.copy()

    def project(self, viewer, x, y, position) -> Point:
        return viewer.screen_to_point_in_plane(
            x, y, position.location, self.normal)

    def _create_guides(self, start_pos, previous_pos, current_pos, scale
                         ) -> typing.Sequence['Handle_AIS_Shape']:
        normal = self.normal
        pos = current_pos

        # avoid ambiguous alignment warning
        if not start_pos.Vz.is_almost_equal(normal):
            pos = current_pos.align(start_pos.Vz, normal)

        v_dim = scale * 10
        rect = RectangularFace(position=pos, color="blue",
                               length=v_dim, width=v_dim)
        ais_rect = make_ais_coloredshape(rect.TopoDS_Shape)
        ais_set_style(ais_rect, 'green', .95)
        return ais_rect,


class Rotation(ManipulationMode):
    """ManipulationMode allowing the user to rotate an object around a normal
    :param `normal`:. The normal can be a vector (or a string that can be
    converted to one, such as 'x', 'y', 'y_'...).

    >>> from parapy.geom import Cube, Position
    ... from parapy.gui.manipulation import ManipulableBase, EndEvent
    ... from parapy.gui.manipulation.modes import Rotation
    ...
    ... class MyCube(Cube, ManipulableBase):
    ...     def on_submit(self, evt:EndEvent):
    ...         self.position = evt.current_position
    ...
    ... # obj can be translated along global X, Y, and Z
    ... obj = MyCube(modes=[
    ...           Rotation('x'), # rotate around VX
    ...           Rotation(normal=Vector(0,1,0), # rotate around VY
    ...                 center=Point(100,0,0), # with a far away center
    ...                 relative=True, # the normal rotates with the object
    ...                 relative_center=False)) # but the center stays where it is
    ...         ])

    Configuration options:
    ======================
    -  :param: `show_guide`: whether while manipulating in this mode, a guide
        should be shown to help the user orient herself.
    -  :param: `increment`: whether the transformation should be rounded at an
        increment or be as continuous as pixels and gui events allow.
    -  :param: `reference`: the axis system relative to which this
        mode is defined. This mode's :param `normal`: is interpreted in terms of
        this reference. By default, the reference is the gizmo's position.
     - :param `center`:
        a point in space around which the rotation should occur. By default,
        rotation occurs around the Mode's reference (which by default is the
        Gizmo's position).
    - :param `relative_center`:
        whether the rotation center should move along with the manipulable,
        or should be interpreted as an abosolute point in space.
    - :param `relative`:
        whether the rotation normal should rotate along with
        the manipulable, or should be interpreted as an abosolute vector.
    -  :param: `handle_color`: the color of the gizmo handle representing this
        mode during manipulation.

    Advanced configuration:
    =======================
    :meth `_create_guides`:. By default this method returns a circle
      representing the rotation direction (orthogonal to the normal),
      and a line representing the rotation normal itself.
      Override it to change this behaviour; for example::

    >>> import typing
    ... from parapy.gui.manipulation import Rotation
    ... from parapy.geom import Position, Cone
    ... from OCC.gui.interactive_objects import make_ais_coloredshape
    ... from OCC.wrapper.AIS import Handle_AIS_Shape  # noqa
    ...
    ... class MyCustomGuideRotationMode(Rotation):
    ...     #a rotation mode that instead of the default 'line and circle' guide
    ...     #has two cones to mark the rotation normal and center.
    ...
    ...     def _make_ais_cone(self, position):
    ...         cone = Cone(radius1=.5, radius2=0, height=1.5, color='purple',
    ...                     position=position.translate(z_=1.5))
    ...         return make_ais_coloredshape(cone.TopoDS_Shape)
    ...
    ...     def _create_guides(self, start_position, current_position,
    ...                          scale) -> typing.Sequence['Handle_AIS_Shape']:
    ...         pos = Position(self.center)
    ...         ais_cone_top = self._make_ais_cone(
    ...             pos.align(pos.Vz, -self.normal))
    ...         ais_cone_bot = self._make_ais_cone(
    ...             pos.align(pos.Vz, self.normal))
    ...         return [ais_cone_top, ais_cone_bot]

    :meth: `_update_guides`: The default implementation does nothing.
    """
    __copy_attrs__ = ('normal', 'center', 'relative_center', 'relative')
    __slots__ = ('_normal', '_center', '_relative_center', '_relative')

    def __init__(self, normal: typing.Union[Vector, str],
                 center: Point = None,
                 show_guide: bool = False,
                 handle_color: typing.Optional[ColorType] = None,
                 increment: typing.Optional[Number] = None,
                 reference: typing.Optional[Position] = None,
                 relative: bool = True,
                 relative_center: bool = True):
        super().__init__(show_guide=show_guide,
                         handle_color=handle_color,
                         increment=increment,
                         reference=reference,
                         relative=relative)
        self._normal = Vector.ensure_vector(normal)
        self._center = center
        self._relative_center = relative_center

    @property
    def normal(self):
        return self._normal

    @property
    def center(self):
        return self._center

    @property
    def relative_center(self):
        return self._relative_center

    def _get_handle_color(self, xyz_component_colors):
        return vector_to_color(self.normal, xyz_component_colors)

    def transformed(self, to_position: Position):
        from_position = self.reference
        kwargs = {}
        # in rotation, relative is rotation-relative: it's about the normal
        relative = self.relative
        if relative:
            new_normal = rebase_vector(self.normal, from_position, to_position)
            kwargs['normal'] = new_normal

        relative_center = self.relative_center

        center = self.center
        if relative_center:
            if center is None:
                center = to_position.location
            else:
                # rebase
                basis_vec = from_position.vector_to(center)
                center = to_position.get_point(*basis_vec)

        kwargs['center'] = center

        # if center is absolute: copy() will pass it down as-is,
        # no transformation done

        return self.copy(reference=to_position,
                         relative_center=relative_center,
                         relative=relative,
                         **kwargs)

    def project(self, viewer, x, y, position) -> Point:
        return viewer.screen_to_point_in_plane(
            x, y, position.location, self.normal)

    def transform(self, start_position, previous_location, current_location):
        if previous_location is None:
            return start_position

        # should never be None by now, still...
        center = self.center or current_location

        v1 = center.vector_to(previous_location)
        v2 = center.vector_to(current_location)

        # calculate real angle, in radians
        try:
            angle, v_rot = v1.angle_and_axis(v2)
        except ZeroDivisionError:
            return start_position

        increment = self.increment  # increment is in radians already
        if increment:
            angle = round_to_increment(angle, increment)

        axis = self.normal
        if v_rot.dot(axis) < 0:
            angle = -angle

        cur_pos = start_position.rotate_around(center, axis, angle)
        return cur_pos

    def _create_guides(self, start_pos, previous_pos, current_pos, scale
                         ) -> typing.Sequence['Handle_AIS_Shape']:
        normal = self.normal
        rotation_center = self.center
        line = make_ais_line(rotation_center, normal)
        pnt = make_ais_point(rotation_center)
        ais_set_style(pnt, color='black')

        pos = current_pos.replace(location=rotation_center)
        if not pos.Vz.is_almost_equal(normal):
            # workaround 'ambiguous alignment' warning
            pos = pos.align('z', normal)

        circle = Circle(position=pos, radius=scale * 2)
        circle = make_ais_coloredshape(circle.TopoDS_Shape)

        return line, pnt, circle


def _get_XYZ_modes(mode_cls: typing.Type[ManipulationMode]) \
        -> typing.Tuple[ManipulationMode]:
    return tuple(mode_cls(ax, handle_color=color) for ax, color in
                 DEFAULT_AXES_TO_COLORS)


PRIMARY_AXIS_TRANSLATIONS = _get_XYZ_modes(Translation)

PRIMARY_AXIS_ROTATIONS = _get_XYZ_modes(Rotation)

PRIMARY_AXIS_PLANAR_TRANSLATIONS = _get_XYZ_modes(PlanarTranslation)

PRIMARY_AXIS_TRANSFORMATIONS = (PRIMARY_AXIS_TRANSLATIONS +
                                PRIMARY_AXIS_ROTATIONS +
                              PRIMARY_AXIS_PLANAR_TRANSLATIONS)

FREEMOVE = FreeMove()

ALL_TRANSFORMATIONS = PRIMARY_AXIS_TRANSFORMATIONS + (FREEMOVE, )