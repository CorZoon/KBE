#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from parapy.geom.generic.positioning import (
    Position)
from parapy.gui.manipulation.modes import ManipulationMode

__all__ = "TransformationState"


class TransformationState:
    """Calculates the current Position of the gizmo based on a
    ``start_position``, and ``x, y`` screen coordinates. Supports translation
    and rotation. Usage:

    >>> obj = TransformationState(viewer)
    ... x, y = 100, 200
    ... # start drag along 'z' axis
    ... obj.start_transformation(ManipulationMode.axis,
    ...     Position(), 'z', x, y)
    ... x, y = 200, 300
    ... new_position = obj.get_current_position(x, y)
    ... obj.stop_transformation()
    ... x, y = 200, 300
    ... # start rotation around 'z' axis
    ... obj.start_transformation(ManipulationMode.rotation,
    ...     new_position, 'z', x, y)
    ... x, y = 300, 400
    ... newer_position = obj.get_current_position(x, y)
    ... obj.stop_transformation()

    :param parapy.gui.viewer.Viewer viewer:
    """
    __slots__ = ('_viewer', '_start_position',
                 '_previous_location',
                 '_mode', '_projector', '_transformator')

    def __init__(self, viewer):
        self._viewer = viewer
        self._mode = None

    def _clear(self):
        self._mode = None
        self._projector, self._transformator = None, None

    def load_transition_def(self, mode: ManipulationMode):
        """sets self, _projector and _transformator,
        depending on the `mode`"""
        state_transition_def = mode.state_transition_def
        self._projector = state_transition_def.projector
        self._transformator = state_transition_def.transformator

    @property
    def mode(self):
        return self._mode

    @property
    def is_active(self):
        return bool(self._mode)

    def start_transformation(self,
                             mode: ManipulationMode,
                             start_position: Position,
                             x: int, y: int):

        self.load_transition_def(mode)
        if self.is_active:
            raise RuntimeError("Stop transformation first.")

        self._start_position = start_position
        self._previous_location = self.project_screen_to_world(x, y)
        self._mode = mode

    def project_screen_to_world(self, x: int, y: int):
        return self._projector(
            self._viewer, x, y,
            position=self._start_position)

    def get_current_position(self, x: int, y: int) -> Position:
        current_location = self.project_screen_to_world(
            x, y)
        # print('current loc', current_location)
        start_position = self._start_position
        previous_location = self._previous_location

        current_position = self._transformator(
            start_position, previous_location, current_location)

        return current_position

    def stop_transformation(self):
        if not self.is_active:
            raise RuntimeError("Start transformation first.")
        self._clear()  # cleanup / reset

