#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import typing

from parapy.geom.generic.positioning import (
    Orientation, Position, Point, Vector)
from parapy.geom.generic.utilities import _transpose, _matrix_times_vector

Transformable = typing.Union[Position, Orientation, Point, Vector]


def _get_matrix(obj):
    if isinstance(obj, Orientation):
        return obj.mat
    elif isinstance(obj, Position):
        return obj.orientation.mat
    else:
        raise TypeError(obj)


def rebase_vector(vector: Vector,
                  from_axis_system: typing.Union[Position, Orientation],
                  to_axis_system: typing.Union[Position, Orientation],
                  normalize=False) -> Vector:
    """Rebases a vector defined in `from_axis_system` into the corresponding
    vector in `to_axis_system`.
    """
    from_mat = _transpose(_get_matrix(from_axis_system))
    to_mat = _get_matrix(to_axis_system)
    origin_vec = _matrix_times_vector(from_mat, vector)
    vec = Vector(*_matrix_times_vector(to_mat, origin_vec))

    if normalize:
        return vec.normalize
    return vec


class Transformation:
    """Class that represents a transformation from one Position or Orientation
    to another.
    If basis and target are Positions: applying the Transformation to Points and
     Positions will translate them; applying it to Orientations, Vectors and
     Positions will rotate them.
    If basis and target are Orientations, nothing will be translated; Vectors,
    Positions and Orientations will still be rotated.
    Usage:
    >>> pos1 = XOY
    ... pos2 = pos1.translate(x=10,y=10).rotate(x=90,deg=True)
    ... trsf = Transformation(pos1, pos2)
    ... trsf.apply(Point(0,0,0)) # Point(10,10,0)
    ... trsf.apply(Vector(1,0,0)) # Vector(1,0,0)
    ... trsf.apply(Vector(0,1,0)) # Point(0,0,1)
    """

    def __init__(self, basis: [Position, Orientation],
                 target: [Position, Orientation]):
        self.basis = basis
        self.target = target

    def apply(self, obj):
        # todo optimize for Orientation, Position
        if isinstance(obj, Vector):
            return rebase_vector(obj, self.basis, self.target)
        if isinstance(obj, Point):
            # this will raise exceptions if basis and target are not Positions,
            # that's ok for now
            basis_vec = self.basis.vector_to(obj)
            return self.target.get_point(*basis_vec)
        if isinstance(obj, Orientation):
            return Orientation(*map(self.apply, obj))
        if isinstance(obj, Position):
            return Position(self.apply(obj.location),
                            self.apply(obj.orientation))
        raise TypeError(obj)


if __name__ == '__main__':
    from parapy.gui import display
    from parapy.core import Base, Part, Attribute, Input
    from parapy.geom import LineSegment, XOY


    class Example(Base):
        pos1 = Input(XOY)
        pos2 = Input(Position().translate(x=5).rotate(z=10))

        def get_axes(self, pos):
            pt = pos.location
            lines = []
            for vec, color in zip(pos.orientation, ['red', 'green', 'blue']):
                line = LineSegment(pt, pt + vec, color=color)
                lines.append(line)
            return lines

        @Attribute(in_tree=True)
        def axis_system_1(self):
            return self.get_axes(self.pos1)

        @Attribute(in_tree=True)
        def axis_system_2(self):
            return self.get_axes(self.pos2)

        @Attribute
        def point(self):
            return Point().translate(x=.7, y=.8)

        @Attribute
        def transformed_point(self):
            return Transformation(self.pos1, self.pos2).apply(self.point)

        @Part
        def line_in(self):
            return LineSegment(self.pos1.location, self.point, color='white')

        @Part
        def line_out(self):
            return LineSegment(self.pos2.location, self.transformed_point,
                               color='black')


    display(Example())
